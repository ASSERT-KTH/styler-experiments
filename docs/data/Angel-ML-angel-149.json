{
    "project_name": "Angel-ML-angel",
    "violation_id": "149",
    "information": {
        "violations": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "checkstyle_idea",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/149/NodeUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/149/NodeUtils.java\nindex 991a2aa82dd..1c631669df3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/149/NodeUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/149/NodeUtils.java\n@@ -14,6 +14,7 @@\n  * the License.\n  *\n  */\n+\n package com.tencent.angel.graph.data;\n \n import com.tencent.angel.ml.math2.VFactory;\n@@ -30,262 +31,262 @@ import org.apache.commons.logging.LogFactory;\n \n public class NodeUtils {\n \n-  private static final Log LOG = LogFactory.getLog(NodeUtils.class);\n-\n-  public static int dataLen(IntFloatVector feats) {\n-    int len = 4 + 4;\n-    if (feats.isDense()) {\n-      len += 4;\n-      len += 4 * feats.getSize();\n-    } else if (feats.isSparse() || feats.isSorted()) {\n-      len += 4;\n-      len += 8 * feats.getSize();\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unsupport storage type \" + feats.getStorage().getClass().getName());\n-    }\n+    private static final Log LOG = LogFactory.getLog(NodeUtils.class);\n \n-    return len;\n-  }\n+    public static int dataLen(IntFloatVector feats) {\n+        int len = 4 + 4;\n+        if (feats.isDense()) {\n+            len += 4;\n+            len += 4 * feats.getSize();\n+        } else if (feats.isSparse() || feats.isSorted()) {\n+            len += 4;\n+            len += 8 * feats.getSize();\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unsupport storage type \" + feats.getStorage().getClass().getName());\n+        }\n \n-  public static void serialize(IntFloatVector feats, ByteBuf output) {\n-    output.writeInt(feats.getDim());\n-    output.writeInt((int) feats.getSize());\n-    if (feats.isDense()) {\n-      output.writeInt(StorageMethod.DENSE.getValue());\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < values.length; i++) {\n-        output.writeFloat(values[i]);\n-      }\n-    } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n-    } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n+        return len;\n     }\n-  }\n \n-  public static IntFloatVector deserialize(ByteBuf input) {\n-    IntFloatVector feats;\n-    int dim = input.readInt();\n-    int len = input.readInt();\n-    StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n-    switch (storageMethod) {\n-      case DENSE: {\n-        float[] values = new float[len];\n-        for (int i = 0; i < len; i++) {\n-          values[i] = input.readFloat();\n+    public static void serialize(IntFloatVector feats, ByteBuf output) {\n+        output.writeInt(feats.getDim());\n+        output.writeInt((int) feats.getSize());\n+        if (feats.isDense()) {\n+            output.writeInt(StorageMethod.DENSE.getValue());\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < values.length; i++) {\n+                output.writeFloat(values[i]);\n+            }\n+        } else if (feats.isSparse()) {\n+            output.writeInt(StorageMethod.SPARSE.getValue());\n+            ObjectIterator<Entry> iter = feats\n+                    .getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Entry entry = iter.next();\n+                output.writeInt(entry.getIntKey());\n+                output.writeFloat(entry.getFloatValue());\n+            }\n+        } else if (feats.isSorted()) {\n+            output.writeInt(StorageMethod.SORTED.getValue());\n+            int[] keys = feats.getStorage().getIndices();\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < keys.length; i++) {\n+                output.writeInt(keys[i]);\n+                output.writeFloat(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupport storage type \");\n         }\n-        feats = VFactory.denseFloatVector(values);\n-        break;\n-      }\n+    }\n \n-      case SPARSE: {\n-        feats = VFactory.sparseFloatVector(dim, len);\n-        for (int i = 0; i < len; i++) {\n-          feats.set(input.readInt(), input.readFloat());\n-        }\n-        break;\n-      }\n+    public static IntFloatVector deserialize(ByteBuf input) {\n+        IntFloatVector feats;\n+        int dim = input.readInt();\n+        int len = input.readInt();\n+        StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n+        switch (storageMethod) {\n+            case DENSE: {\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.denseFloatVector(values);\n+                break;\n+            }\n \n-      case SORTED: {\n-        int[] keys = new int[len];\n-        float[] values = new float[len];\n-        for (int i = 0; i < len; i++) {\n-          keys[i] = input.readInt();\n-          values[i] = input.readFloat();\n-        }\n-        feats = VFactory.sortedFloatVector(dim, keys, values);\n-        break;\n-      }\n+            case SPARSE: {\n+                feats = VFactory.sparseFloatVector(dim, len);\n+                for (int i = 0; i < len; i++) {\n+                    feats.set(input.readInt(), input.readFloat());\n+                }\n+                break;\n+            }\n \n-      default:\n-        throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n-    }\n+            case SORTED: {\n+                int[] keys = new int[len];\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    keys[i] = input.readInt();\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.sortedFloatVector(dim, keys, values);\n+                break;\n+            }\n \n-    return feats;\n-  }\n+            default:\n+                throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n+        }\n \n-  public static void serialize(IntFloatVector feats, DataOutputStream output) throws IOException {\n-    output.writeInt(feats.getDim());\n-    output.writeInt((int) feats.getSize());\n-    if (feats.isDense()) {\n-      output.writeInt(StorageMethod.DENSE.getValue());\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < values.length; i++) {\n-        output.writeFloat(values[i]);\n-      }\n-    } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n-    } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n+        return feats;\n     }\n-  }\n \n-  public static IntFloatVector deserialize(DataInputStream input) throws IOException {\n-    IntFloatVector feats;\n-    int dim = input.readInt();\n-    int len = input.readInt();\n-    StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n-    switch (storageMethod) {\n-      case DENSE: {\n-        float[] values = new float[len];\n-        for (int i = 0; i < len; i++) {\n-          values[i] = input.readFloat();\n+    public static void serialize(IntFloatVector feats, DataOutputStream output) throws IOException {\n+        output.writeInt(feats.getDim());\n+        output.writeInt((int) feats.getSize());\n+        if (feats.isDense()) {\n+            output.writeInt(StorageMethod.DENSE.getValue());\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < values.length; i++) {\n+                output.writeFloat(values[i]);\n+            }\n+        } else if (feats.isSparse()) {\n+            output.writeInt(StorageMethod.SPARSE.getValue());\n+            ObjectIterator<Entry> iter = feats\n+                    .getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Entry entry = iter.next();\n+                output.writeInt(entry.getIntKey());\n+                output.writeFloat(entry.getFloatValue());\n+            }\n+        } else if (feats.isSorted()) {\n+            output.writeInt(StorageMethod.SORTED.getValue());\n+            int[] keys = feats.getStorage().getIndices();\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < keys.length; i++) {\n+                output.writeInt(keys[i]);\n+                output.writeFloat(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupport storage type \");\n         }\n-        feats = VFactory.denseFloatVector(values);\n-        break;\n-      }\n+    }\n \n-      case SPARSE: {\n-        feats = VFactory.sparseFloatVector(dim, len);\n-        for (int i = 0; i < len; i++) {\n-          feats.set(input.readInt(), input.readFloat());\n-        }\n-        break;\n-      }\n+    public static IntFloatVector deserialize(DataInputStream input) throws IOException {\n+        IntFloatVector feats;\n+        int dim = input.readInt();\n+        int len = input.readInt();\n+        StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n+        switch (storageMethod) {\n+            case DENSE: {\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.denseFloatVector(values);\n+                break;\n+            }\n+\n+            case SPARSE: {\n+                feats = VFactory.sparseFloatVector(dim, len);\n+                for (int i = 0; i < len; i++) {\n+                    feats.set(input.readInt(), input.readFloat());\n+                }\n+                break;\n+            }\n \n-      case SORTED: {\n-        int[] keys = new int[len];\n-        float[] values = new float[len];\n-        for (int i = 0; i < len; i++) {\n-          keys[i] = input.readInt();\n-          values[i] = input.readFloat();\n+            case SORTED: {\n+                int[] keys = new int[len];\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    keys[i] = input.readInt();\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.sortedFloatVector(dim, keys, values);\n+                break;\n+            }\n+\n+            default:\n+                throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n         }\n-        feats = VFactory.sortedFloatVector(dim, keys, values);\n-        break;\n-      }\n \n-      default:\n-        throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n+        return feats;\n     }\n \n-    return feats;\n-  }\n-\n-  public static void serialize(float[] feats, ByteBuf output) {\n-    if (feats != null) {\n-      output.writeInt(feats.length);\n-      for (int i = 0; i < feats.length; i++) {\n-        output.writeFloat(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+    public static void serialize(float[] feats, ByteBuf output) {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeFloat(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n     }\n-  }\n \n-  public static void serialize(double[] feats, ByteBuf output) throws IOException {\n-    if (feats != null) {\n-      output.writeInt(feats.length);\n-      for (int i = 0; i < feats.length; i++) {\n-        output.writeDouble(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+    public static void serialize(double[] feats, ByteBuf output) throws IOException {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeDouble(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n     }\n-  }\n \n \n-  public static void serialize(float[] feats, DataOutputStream output) throws IOException {\n-    if (feats != null) {\n-      output.writeInt(feats.length);\n-      for (int i = 0; i < feats.length; i++) {\n-        output.writeFloat(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+    public static void serialize(float[] feats, DataOutputStream output) throws IOException {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeFloat(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n     }\n-  }\n \n-  public static void serialize(double[] feats, DataOutputStream output) throws IOException {\n-    if (feats != null) {\n-      output.writeInt(feats.length);\n-      for (int i = 0; i < feats.length; i++) {\n-        output.writeDouble(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+    public static void serialize(double[] feats, DataOutputStream output) throws IOException {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeDouble(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n     }\n-  }\n \n \n-  public static float[] deserializeFloats(DataInputStream input) throws IOException {\n-    int len = input.readInt();\n-    if (len > 0) {\n-      float[] res = new float[len];\n-      for (int i = 0; i < len; i++) {\n-        res[i] = input.readInt();\n-      }\n-      return res;\n-    } else {\n-      return null;\n+    public static float[] deserializeFloats(DataInputStream input) throws IOException {\n+        int len = input.readInt();\n+        if (len > 0) {\n+            float[] res = new float[len];\n+            for (int i = 0; i < len; i++) {\n+                res[i] = input.readInt();\n+            }\n+            return res;\n+        } else {\n+            return null;\n+        }\n     }\n-  }\n \n-  public static float[] deserializeFloats(ByteBuf input) {\n-    int len = input.readInt();\n-    if (len > 0) {\n-      float[] res = new float[len];\n-      for (int i = 0; i < len; i++) {\n-        res[i] = input.readFloat();\n-      }\n-      return res;\n-    } else {\n-      return null;\n+    public static float[] deserializeFloats(ByteBuf input) {\n+        int len = input.readInt();\n+        if (len > 0) {\n+            float[] res = new float[len];\n+            for (int i = 0; i < len; i++) {\n+                res[i] = input.readFloat();\n+            }\n+            return res;\n+        } else {\n+            return null;\n+        }\n     }\n-  }\n \n-  public static double[] deserializeDoubles(ByteBuf input) {\n-    int len = input.readInt();\n-    if (len > 0) {\n-      double[] res = new double[len];\n-      for (int i = 0; i < len; i++) {\n-        res[i] = input.readDouble();\n-      }\n-      return res;\n-    } else {\n-      return null;\n+    public static double[] deserializeDoubles(ByteBuf input) {\n+        int len = input.readInt();\n+        if (len > 0) {\n+            double[] res = new double[len];\n+            for (int i = 0; i < len; i++) {\n+                res[i] = input.readDouble();\n+            }\n+            return res;\n+        } else {\n+            return null;\n+        }\n     }\n-  }\n \n-  public static int dataLen(float[] feats) {\n-    return 4 + (feats == null ? 0 : feats.length * 4);\n-  }\n+    public static int dataLen(float[] feats) {\n+        return 4 + (feats == null ? 0 : feats.length * 4);\n+    }\n \n-  public static int dataLenShortFromFloat(float[] feats) {\n-    return 4 + (feats == null ? 0 : feats.length * 2);\n-  }\n+    public static int dataLenShortFromFloat(float[] feats) {\n+        return 4 + (feats == null ? 0 : feats.length * 2);\n+    }\n \n-  public static int dataLen(double[] feats) {\n-    return 4 + (feats == null ? 0 : feats.length * 8);\n-  }\n+    public static int dataLen(double[] feats) {\n+        return 4 + (feats == null ? 0 : feats.length * 8);\n+    }\n }\n",
            "diff_size": 311
        },
        {
            "tool": "naturalize",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "44",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/149/NodeUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/149/NodeUtils.java\nindex 991a2aa82dd..bdd7f9f4a4c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/149/NodeUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/149/NodeUtils.java\n@@ -41,8 +41,7 @@ public class NodeUtils {\n       len += 4;\n       len += 8 * feats.getSize();\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unsupport storage type \" + feats.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unsupport storage type \" + feats.getStorage().getClass().getName());\n     }\n \n     return len;\n@@ -59,9 +58,8 @@ public class NodeUtils {\n       }\n     } else if (feats.isSparse()) {\n       output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n+      ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+while (iter.hasNext()) {\n         Entry entry = iter.next();\n         output.writeInt(entry.getIntKey());\n         output.writeFloat(entry.getFloatValue());\n@@ -115,7 +113,7 @@ public class NodeUtils {\n \n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n-    }\n+  }\n \n     return feats;\n   }\n@@ -131,9 +129,8 @@ public class NodeUtils {\n       }\n     } else if (feats.isSparse()) {\n       output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n+      ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+while (iter.hasNext()) {\n         Entry entry = iter.next();\n         output.writeInt(entry.getIntKey());\n         output.writeFloat(entry.getFloatValue());\n@@ -187,7 +184,7 @@ public class NodeUtils {\n \n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n-    }\n+  }\n \n     return feats;\n   }\n@@ -288,4 +285,4 @@ public class NodeUtils {\n   public static int dataLen(double[] feats) {\n     return 4 + (feats == null ? 0 : feats.length * 8);\n   }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 11
        },
        {
            "tool": "codebuff",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "44",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/149/NodeUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/149/NodeUtils.java\nindex 991a2aa82dd..1cb36d23f30 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/149/NodeUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/149/NodeUtils.java\n@@ -38,13 +38,11 @@ public class NodeUtils {\n       len += 4;\n       len += 4 * feats.getSize();\n     } else if (feats.isSparse() || feats.isSorted()) {\n-      len += 4;\n-      len += 8 * feats.getSize();\n+             len += 4;\n+             len += 8 * feats.getSize();\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unsupport storage type \" + feats.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unsupport storage type \" + feats.getStorage().getClass().getName());\n     }\n-\n     return len;\n   }\n \n@@ -58,25 +56,25 @@ public class NodeUtils {\n         output.writeFloat(values[i]);\n       }\n     } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n+             output.writeInt(StorageMethod.SPARSE.getValue());\n+             ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Entry entry = iter.next();\n+               output.writeInt(entry.getIntKey());\n+               output.writeFloat(entry.getFloatValue());\n+             }\n     } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n-    }\n+             output.writeInt(StorageMethod.SORTED.getValue());\n+\n+             int[] keys = feats.getStorage().getIndices();\n+             float[] values = feats.getStorage().getValues();\n+             for (int i = 0; i < keys.length; i++) {\n+               output.writeInt(keys[i]);\n+               output.writeFloat(values[i]);\n+             }\n+           } else {\n+             throw new UnsupportedOperationException(\"Unsupport storage type \");\n+           }\n   }\n \n   public static IntFloatVector deserialize(ByteBuf input) {\n@@ -116,7 +114,6 @@ public class NodeUtils {\n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n     }\n-\n     return feats;\n   }\n \n@@ -130,25 +127,25 @@ public class NodeUtils {\n         output.writeFloat(values[i]);\n       }\n     } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n+             output.writeInt(StorageMethod.SPARSE.getValue());\n+             ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Entry entry = iter.next();\n+               output.writeInt(entry.getIntKey());\n+               output.writeFloat(entry.getFloatValue());\n+             }\n     } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n-    }\n+             output.writeInt(StorageMethod.SORTED.getValue());\n+\n+             int[] keys = feats.getStorage().getIndices();\n+             float[] values = feats.getStorage().getValues();\n+             for (int i = 0; i < keys.length; i++) {\n+               output.writeInt(keys[i]);\n+               output.writeFloat(values[i]);\n+             }\n+           } else {\n+             throw new UnsupportedOperationException(\"Unsupport storage type \");\n+           }\n   }\n \n   public static IntFloatVector deserialize(DataInputStream input) throws IOException {\n@@ -188,7 +185,6 @@ public class NodeUtils {\n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n     }\n-\n     return feats;\n   }\n \n@@ -214,7 +210,6 @@ public class NodeUtils {\n     }\n   }\n \n-\n   public static void serialize(float[] feats, DataOutputStream output) throws IOException {\n     if (feats != null) {\n       output.writeInt(feats.length);\n@@ -237,7 +232,6 @@ public class NodeUtils {\n     }\n   }\n \n-\n   public static float[] deserializeFloats(DataInputStream input) throws IOException {\n     int len = input.readInt();\n     if (len > 0) {\n@@ -288,4 +282,5 @@ public class NodeUtils {\n   public static int dataLen(double[] feats) {\n     return 4 + (feats == null ? 0 : feats.length * 8);\n   }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 49
        },
        {
            "tool": "styler_random",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "checkstyle_idea",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}