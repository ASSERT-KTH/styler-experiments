{
    "project_name": "Angel-ML-angel",
    "violation_id": "320",
    "information": {
        "violations": [
            {
                "line": "795",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "  }\n\n  public static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta, LongDoubleVector vector) {\n    LongDoubleVectorStorage storage = vector.getStorage();\n    if (storage.isSparse()) {\n      // Get keys and values",
    "results": [
        {
            "tool": "styler",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/./experiments/projects/Angel-ML-angel/styler/05_predictions/final/files-repaired/320/RangeRouterUtils.java\nindex 1a354ff075b..c1a5bba1489 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/./experiments/projects/Angel-ML-angel/styler/05_predictions/final/files-repaired/320/RangeRouterUtils.java\n@@ -792,8 +792,9 @@ public class RangeRouterUtils {\n     }\n   }\n \n-  public static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta, LongDoubleVector vector) {\n-    LongDoubleVectorStorage storage = vector.getStorage();\n+  public\n+  static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta, LongDoubleVector vector) {\n+     LongDoubleVectorStorage storage = vector.getStorage();\n     if (storage.isSparse()) {\n       // Get keys and values\n       LongDoubleSparseVectorStorage sparseStorage = (LongDoubleSparseVectorStorage) storage;\n",
            "diff_size": 3
        },
        {
            "tool": "checkstyle_idea",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/320/RangeRouterUtils.java\nindex 1a354ff075b..01b05d2de0b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/320/RangeRouterUtils.java\n@@ -48,815 +48,823 @@ import java.util.Arrays;\n \n public class RangeRouterUtils {\n \n-  /////////////////////////////////////////////////////////////////////////////////////////\n-  // keys split: range split only support int/long key\n-  /////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n-    if (!isSorted) {\n-      Arrays.sort(keys);\n-    }\n-\n-    if(keys[keys.length - 1] >= matrixMeta.getColNum()) {\n-      System.out.println(\"Error happened!!!\");\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyPart[] dataParts = new KeyPart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      if (length != 0) {\n-        dataParts[partIndex] = new RangeViewIntKeysPart(rowId, keys, keyIndex - length, keyIndex);\n-      }\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n-    if (!isSorted) {\n-      Arrays.sort(keys);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyPart[] dataParts = new KeyPart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      if (length != 0) {\n-        dataParts[partIndex] = new RangeViewLongKeysPart(rowId, keys, keyIndex - length, keyIndex);\n-      }\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n-  }\n-\n-  /////////////////////////////////////////////////////////////////////////////////////////\n-  // keys/values pair split: int key, float/double/int/long/any values\n-  /////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      if (length != 0) {\n-        dataParts[partIndex] = new RangeViewIntKeysFloatValuesPart(rowId, keys, values,\n-            keyIndex - length, keyIndex);\n-      }\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysDoubleValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys/values by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      int[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysIntValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys/values by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysLongValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys/values by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysAnyValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /////////////////////////////////////////////////////////////////////////////////////////\n-  // keys/values pair split: long key, float/double/int/long/any values\n-  /////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      if (length != 0) {\n-        dataParts[partIndex] = new RangeViewLongKeysFloatValuesPart(rowId, keys, values,\n-            keyIndex - length, keyIndex);\n-      }\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysDoubleValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      int[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysIntValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysLongValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if (!isSorted) {\n-      Sort.quickSort(keys, values, 0, keys.length - 1);\n-    }\n-\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    int keyIndex = 0;\n-    int partIndex = 0;\n-    while (keyIndex < keys.length || partIndex < matrixParts.length) {\n-      int length = 0;\n-      long endOffset = matrixParts[partIndex].getEndCol();\n-      while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n-        keyIndex++;\n-        length++;\n-      }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysAnyValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n-    }\n-    return dataParts;\n-  }\n-\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      float[] values, boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n-  }\n-\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      float[] values, boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n-  }\n-\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      double[] values, boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n-  }\n-\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      double[] values, boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n-  }\n-\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      IElement[] values, boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n-  }\n-\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      IElement[] values, boolean isSorted) {\n-    throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n-  }\n-\n-  /////////////////////////////////////////////////////////////////////////////////////////\n-  // values pair split: float/double/int/long/any values\n-  /////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split values\n-   *\n-   * @param matrixMeta matrix meta\n-   * @param rowId row id\n-   * @param values values\n-   * @return value splits\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, double[] values) {\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewDoubleValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split values\n-   *\n-   * @param matrixMeta matrix meta\n-   * @param rowId row id\n-   * @param values values\n-   * @return value splits\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, float[] values) {\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewFloatValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split values\n-   *\n-   * @param matrixMeta matrix meta\n-   * @param rowId row id\n-   * @param values values\n-   * @return value splits\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] values) {\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewIntValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split values\n-   *\n-   * @param matrixMeta matrix meta\n-   * @param rowId row id\n-   * @param values values\n-   * @return value splits\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] values) {\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewLongValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split values\n-   *\n-   * @param matrixMeta matrix meta\n-   * @param rowId row id\n-   * @param values values\n-   * @return value splits\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] values) {\n-    PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n-    KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n-    for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewAnyValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n-    return dataParts;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param vector Matrix vector\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, Vector vector) {\n-    switch (vector.getType()) {\n-      case T_DOUBLE_SPARSE:\n-      case T_DOUBLE_DENSE:\n-        return splitIntDoubleVector(matrixMeta, (IntDoubleVector) vector);\n-\n-      case T_FLOAT_SPARSE:\n-      case T_FLOAT_DENSE:\n-        return splitIntFloatVector(matrixMeta, (IntFloatVector) vector);\n-\n-      case T_INT_DENSE:\n-      case T_INT_SPARSE:\n-        return splitIntIntVector(matrixMeta, (IntIntVector) vector);\n-\n-      case T_LONG_DENSE:\n-      case T_LONG_SPARSE:\n-        return splitIntLongVector(matrixMeta, (IntLongVector) vector);\n-\n-      case T_DOUBLE_SPARSE_LONGKEY:\n-        return splitLongDoubleVector(matrixMeta, (LongDoubleVector) vector);\n-\n-      case T_FLOAT_SPARSE_LONGKEY:\n-        return splitLongFloatVector(matrixMeta, (LongFloatVector) vector);\n-\n-      case T_INT_SPARSE_LONGKEY:\n-        return splitLongIntVector(matrixMeta, (LongIntVector) vector);\n-\n-      case T_LONG_SPARSE_LONGKEY:\n-        return splitLongLongVector(matrixMeta, (LongLongVector) vector);\n-\n-\n-      default:\n-        throw new UnsupportedOperationException(\"Unsupport vector type \" + vector.getType());\n-    }\n-  }\n-\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param vector Matrix vector\n-   * @return partition key to key partition map\n-   */\n-  public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector vector) {\n-    Vector[] vectors = new Vector[1];\n-    vectors[0] = vector;\n-    return splitStream(matrixMeta, vectors);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param vectors Matrix vectors\n-   * @return partition key to key partition map\n-   */\n-  public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector[] vectors) {\n-    CompStreamKeyValuePart[] dataParts = new CompStreamKeyValuePart[matrixMeta.getPartitionNum()];\n-    KeyValuePart[][] subDataParts = new KeyValuePart[vectors.length][];\n-\n-    for (int i = 0; i < vectors.length; i++) {\n-      subDataParts[i] = split(matrixMeta, vectors[i]);\n-    }\n-\n-    for (int i = 0; i < dataParts.length; i++) {\n-      dataParts[i] = new CompStreamKeyValuePart(vectors.length);\n-      for (int j = 0; j < vectors.length; j++) {\n-        dataParts[i].add(subDataParts[j][i]);\n-      }\n-    }\n-\n-    return dataParts;\n-  }\n-\n-  public static KeyValuePart[] splitIntDoubleVector(MatrixMeta matrixMeta, IntDoubleVector vector) {\n-    IntDoubleVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      IntDoubleSparseVectorStorage sparseStorage = (IntDoubleSparseVectorStorage) storage;\n-      int[] keys = sparseStorage.getIndices();\n-      double[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else if (storage.isDense()) {\n-      // Get values\n-      IntDoubleDenseVectorStorage denseStorage = (IntDoubleDenseVectorStorage) storage;\n-      double[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n-    } else {\n-      // Key and value array pair\n-      IntDoubleSortedVectorStorage sortStorage = (IntDoubleSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      double[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n-\n-  public static KeyValuePart[] splitIntFloatVector(MatrixMeta matrixMeta, IntFloatVector vector) {\n-    IntFloatVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      IntFloatSparseVectorStorage sparseStorage = (IntFloatSparseVectorStorage) storage;\n-      int[] keys = sparseStorage.getIndices();\n-      float[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else if (storage.isDense()) {\n-      // Get values\n-      IntFloatDenseVectorStorage denseStorage = (IntFloatDenseVectorStorage) storage;\n-      float[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n-    } else {\n-      // Key and value array pair\n-      IntFloatSortedVectorStorage sortStorage = (IntFloatSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      float[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n-\n-  public static KeyValuePart[] splitIntIntVector(MatrixMeta matrixMeta, IntIntVector vector) {\n-    IntIntVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      IntIntSparseVectorStorage sparseStorage = (IntIntSparseVectorStorage) storage;\n-      int[] keys = sparseStorage.getIndices();\n-      int[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else if (storage.isDense()) {\n-      // Get values\n-      IntIntDenseVectorStorage denseStorage = (IntIntDenseVectorStorage) storage;\n-      int[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n-    } else {\n-      // Key and value array pair\n-      IntIntSortedVectorStorage sortStorage = (IntIntSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      int[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n-\n-  public static KeyValuePart[] splitIntLongVector(MatrixMeta matrixMeta, IntLongVector vector) {\n-    IntLongVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      IntLongSparseVectorStorage sparseStorage = (IntLongSparseVectorStorage) storage;\n-      int[] keys = sparseStorage.getIndices();\n-      long[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else if (storage.isDense()) {\n-      // Get values\n-      IntLongDenseVectorStorage denseStorage = (IntLongDenseVectorStorage) storage;\n-      long[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n-    } else {\n-      // Key and value array pair\n-      IntLongSortedVectorStorage sortStorage = (IntLongSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      long[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n-\n-  public static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta, LongDoubleVector vector) {\n-    LongDoubleVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      LongDoubleSparseVectorStorage sparseStorage = (LongDoubleSparseVectorStorage) storage;\n-      long[] keys = sparseStorage.getIndices();\n-      double[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else {\n-      // Key and value array pair\n-      LongDoubleSortedVectorStorage sortStorage = (LongDoubleSortedVectorStorage) storage;\n-      long[] keys = sortStorage.getIndices();\n-      double[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n-\n-  public static KeyValuePart[] splitLongFloatVector(MatrixMeta matrixMeta, LongFloatVector vector) {\n-    LongFloatVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      LongFloatSparseVectorStorage sparseStorage = (LongFloatSparseVectorStorage) storage;\n-      long[] keys = sparseStorage.getIndices();\n-      float[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else {\n-      // Key and value array pair\n-      LongFloatSortedVectorStorage sortStorage = (LongFloatSortedVectorStorage) storage;\n-      long[] keys = sortStorage.getIndices();\n-      float[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n-\n-  public static KeyValuePart[] splitLongIntVector(MatrixMeta matrixMeta, LongIntVector vector) {\n-    LongIntVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      LongIntSparseVectorStorage sparseStorage = (LongIntSparseVectorStorage) storage;\n-      long[] keys = sparseStorage.getIndices();\n-      int[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else {\n-      // Key and value array pair\n-      LongIntSortedVectorStorage sortStorage = (LongIntSortedVectorStorage) storage;\n-      long[] keys = sortStorage.getIndices();\n-      int[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n-\n-  public static KeyValuePart[] splitLongLongVector(MatrixMeta matrixMeta, LongLongVector vector) {\n-    LongLongVectorStorage storage = vector.getStorage();\n-    if (storage.isSparse()) {\n-      // Get keys and values\n-      LongLongSparseVectorStorage sparseStorage = (LongLongSparseVectorStorage) storage;\n-      long[] keys = sparseStorage.getIndices();\n-      long[] values = sparseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, false);\n-    } else {\n-      // Key and value array pair\n-      LongLongSortedVectorStorage sortStorage = (LongLongSortedVectorStorage) storage;\n-      long[] keys = sortStorage.getIndices();\n-      long[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n-    }\n-  }\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+    // keys split: range split only support int/long key\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n+        if (!isSorted) {\n+            Arrays.sort(keys);\n+        }\n+\n+        if (keys[keys.length - 1] >= matrixMeta.getColNum()) {\n+            System.out.println(\"Error happened!!!\");\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyPart[] dataParts = new KeyPart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            if (length != 0) {\n+                dataParts[partIndex] =\n+                        new RangeViewIntKeysPart(rowId, keys, keyIndex - length, keyIndex);\n+            }\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n+        if (!isSorted) {\n+            Arrays.sort(keys);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyPart[] dataParts = new KeyPart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            if (length != 0) {\n+                dataParts[partIndex] =\n+                        new RangeViewLongKeysPart(rowId, keys, keyIndex - length, keyIndex);\n+            }\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n+                                  boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n+                                  boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+    // keys/values pair split: int key, float/double/int/long/any values\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       float[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            if (length != 0) {\n+                dataParts[partIndex] = new RangeViewIntKeysFloatValuesPart(rowId, keys, values,\n+                        keyIndex - length, keyIndex);\n+            }\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       double[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewIntKeysDoubleValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys/values by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       int[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewIntKeysIntValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys/values by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       long[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewIntKeysLongValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys/values by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       IElement[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewIntKeysAnyValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+    // keys/values pair split: long key, float/double/int/long/any values\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       float[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            if (length != 0) {\n+                dataParts[partIndex] = new RangeViewLongKeysFloatValuesPart(rowId, keys, values,\n+                        keyIndex - length, keyIndex);\n+            }\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       double[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewLongKeysDoubleValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       int[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewLongKeysIntValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       long[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewLongKeysLongValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       IElement[] values, boolean isSorted) {\n+        if (!isSorted) {\n+            Sort.quickSort(keys, values, 0, keys.length - 1);\n+        }\n+\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        int keyIndex = 0;\n+        int partIndex = 0;\n+        while (keyIndex < keys.length || partIndex < matrixParts.length) {\n+            int length = 0;\n+            long endOffset = matrixParts[partIndex].getEndCol();\n+            while (keyIndex < keys.length && keys[keyIndex] < endOffset) {\n+                keyIndex++;\n+                length++;\n+            }\n+\n+            dataParts[partIndex] = new RangeViewLongKeysAnyValuesPart(rowId, keys, values,\n+                    keyIndex - length, keyIndex);\n+            partIndex++;\n+        }\n+        return dataParts;\n+    }\n+\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n+                                       float[] values, boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n+    }\n+\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n+                                       float[] values, boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n+    }\n+\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n+                                       double[] values, boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n+    }\n+\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n+                                       double[] values, boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n+    }\n+\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n+                                       IElement[] values, boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n+    }\n+\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n+                                       IElement[] values, boolean isSorted) {\n+        throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+    // values pair split: float/double/int/long/any values\n+    /////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split values\n+     *\n+     * @param matrixMeta matrix meta\n+     * @param rowId      row id\n+     * @param values     values\n+     * @return value splits\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, double[] values) {\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        for (int i = 0; i < matrixParts.length; i++) {\n+            dataParts[i] = new RangeViewDoubleValuesPart(rowId, values,\n+                    (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split values\n+     *\n+     * @param matrixMeta matrix meta\n+     * @param rowId      row id\n+     * @param values     values\n+     * @return value splits\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, float[] values) {\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        for (int i = 0; i < matrixParts.length; i++) {\n+            dataParts[i] = new RangeViewFloatValuesPart(rowId, values,\n+                    (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split values\n+     *\n+     * @param matrixMeta matrix meta\n+     * @param rowId      row id\n+     * @param values     values\n+     * @return value splits\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] values) {\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        for (int i = 0; i < matrixParts.length; i++) {\n+            dataParts[i] = new RangeViewIntValuesPart(rowId, values,\n+                    (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split values\n+     *\n+     * @param matrixMeta matrix meta\n+     * @param rowId      row id\n+     * @param values     values\n+     * @return value splits\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] values) {\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        for (int i = 0; i < matrixParts.length; i++) {\n+            dataParts[i] = new RangeViewLongValuesPart(rowId, values,\n+                    (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split values\n+     *\n+     * @param matrixMeta matrix meta\n+     * @param rowId      row id\n+     * @param values     values\n+     * @return value splits\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] values) {\n+        PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n+        KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n+\n+        for (int i = 0; i < matrixParts.length; i++) {\n+            dataParts[i] = new RangeViewAnyValuesPart(rowId, values,\n+                    (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+        }\n+        return dataParts;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param vector     Matrix vector\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, Vector vector) {\n+        switch (vector.getType()) {\n+            case T_DOUBLE_SPARSE:\n+            case T_DOUBLE_DENSE:\n+                return splitIntDoubleVector(matrixMeta, (IntDoubleVector) vector);\n+\n+            case T_FLOAT_SPARSE:\n+            case T_FLOAT_DENSE:\n+                return splitIntFloatVector(matrixMeta, (IntFloatVector) vector);\n+\n+            case T_INT_DENSE:\n+            case T_INT_SPARSE:\n+                return splitIntIntVector(matrixMeta, (IntIntVector) vector);\n+\n+            case T_LONG_DENSE:\n+            case T_LONG_SPARSE:\n+                return splitIntLongVector(matrixMeta, (IntLongVector) vector);\n+\n+            case T_DOUBLE_SPARSE_LONGKEY:\n+                return splitLongDoubleVector(matrixMeta, (LongDoubleVector) vector);\n+\n+            case T_FLOAT_SPARSE_LONGKEY:\n+                return splitLongFloatVector(matrixMeta, (LongFloatVector) vector);\n+\n+            case T_INT_SPARSE_LONGKEY:\n+                return splitLongIntVector(matrixMeta, (LongIntVector) vector);\n+\n+            case T_LONG_SPARSE_LONGKEY:\n+                return splitLongLongVector(matrixMeta, (LongLongVector) vector);\n+\n+\n+            default:\n+                throw new UnsupportedOperationException(\n+                        \"Unsupport vector type \" + vector.getType());\n+        }\n+    }\n+\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param vector     Matrix vector\n+     * @return partition key to key partition map\n+     */\n+    public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector vector) {\n+        Vector[] vectors = new Vector[1];\n+        vectors[0] = vector;\n+        return splitStream(matrixMeta, vectors);\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param vectors    Matrix vectors\n+     * @return partition key to key partition map\n+     */\n+    public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector[] vectors) {\n+        CompStreamKeyValuePart[] dataParts =\n+                new CompStreamKeyValuePart[matrixMeta.getPartitionNum()];\n+        KeyValuePart[][] subDataParts = new KeyValuePart[vectors.length][];\n+\n+        for (int i = 0; i < vectors.length; i++) {\n+            subDataParts[i] = split(matrixMeta, vectors[i]);\n+        }\n+\n+        for (int i = 0; i < dataParts.length; i++) {\n+            dataParts[i] = new CompStreamKeyValuePart(vectors.length);\n+            for (int j = 0; j < vectors.length; j++) {\n+                dataParts[i].add(subDataParts[j][i]);\n+            }\n+        }\n+\n+        return dataParts;\n+    }\n+\n+    public static KeyValuePart[] splitIntDoubleVector(MatrixMeta matrixMeta,\n+                                                      IntDoubleVector vector) {\n+        IntDoubleVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            IntDoubleSparseVectorStorage sparseStorage = (IntDoubleSparseVectorStorage) storage;\n+            int[] keys = sparseStorage.getIndices();\n+            double[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else if (storage.isDense()) {\n+            // Get values\n+            IntDoubleDenseVectorStorage denseStorage = (IntDoubleDenseVectorStorage) storage;\n+            double[] values = denseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), values);\n+        } else {\n+            // Key and value array pair\n+            IntDoubleSortedVectorStorage sortStorage = (IntDoubleSortedVectorStorage) storage;\n+            int[] keys = sortStorage.getIndices();\n+            double[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n+\n+    public static KeyValuePart[] splitIntFloatVector(MatrixMeta matrixMeta, IntFloatVector vector) {\n+        IntFloatVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            IntFloatSparseVectorStorage sparseStorage = (IntFloatSparseVectorStorage) storage;\n+            int[] keys = sparseStorage.getIndices();\n+            float[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else if (storage.isDense()) {\n+            // Get values\n+            IntFloatDenseVectorStorage denseStorage = (IntFloatDenseVectorStorage) storage;\n+            float[] values = denseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), values);\n+        } else {\n+            // Key and value array pair\n+            IntFloatSortedVectorStorage sortStorage = (IntFloatSortedVectorStorage) storage;\n+            int[] keys = sortStorage.getIndices();\n+            float[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n+\n+    public static KeyValuePart[] splitIntIntVector(MatrixMeta matrixMeta, IntIntVector vector) {\n+        IntIntVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            IntIntSparseVectorStorage sparseStorage = (IntIntSparseVectorStorage) storage;\n+            int[] keys = sparseStorage.getIndices();\n+            int[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else if (storage.isDense()) {\n+            // Get values\n+            IntIntDenseVectorStorage denseStorage = (IntIntDenseVectorStorage) storage;\n+            int[] values = denseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), values);\n+        } else {\n+            // Key and value array pair\n+            IntIntSortedVectorStorage sortStorage = (IntIntSortedVectorStorage) storage;\n+            int[] keys = sortStorage.getIndices();\n+            int[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n+\n+    public static KeyValuePart[] splitIntLongVector(MatrixMeta matrixMeta, IntLongVector vector) {\n+        IntLongVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            IntLongSparseVectorStorage sparseStorage = (IntLongSparseVectorStorage) storage;\n+            int[] keys = sparseStorage.getIndices();\n+            long[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else if (storage.isDense()) {\n+            // Get values\n+            IntLongDenseVectorStorage denseStorage = (IntLongDenseVectorStorage) storage;\n+            long[] values = denseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), values);\n+        } else {\n+            // Key and value array pair\n+            IntLongSortedVectorStorage sortStorage = (IntLongSortedVectorStorage) storage;\n+            int[] keys = sortStorage.getIndices();\n+            long[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n+\n+    public static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta,\n+                                                       LongDoubleVector vector) {\n+        LongDoubleVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            LongDoubleSparseVectorStorage sparseStorage = (LongDoubleSparseVectorStorage) storage;\n+            long[] keys = sparseStorage.getIndices();\n+            double[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else {\n+            // Key and value array pair\n+            LongDoubleSortedVectorStorage sortStorage = (LongDoubleSortedVectorStorage) storage;\n+            long[] keys = sortStorage.getIndices();\n+            double[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n+\n+    public static KeyValuePart[] splitLongFloatVector(MatrixMeta matrixMeta,\n+                                                      LongFloatVector vector) {\n+        LongFloatVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            LongFloatSparseVectorStorage sparseStorage = (LongFloatSparseVectorStorage) storage;\n+            long[] keys = sparseStorage.getIndices();\n+            float[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else {\n+            // Key and value array pair\n+            LongFloatSortedVectorStorage sortStorage = (LongFloatSortedVectorStorage) storage;\n+            long[] keys = sortStorage.getIndices();\n+            float[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n+\n+    public static KeyValuePart[] splitLongIntVector(MatrixMeta matrixMeta, LongIntVector vector) {\n+        LongIntVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            LongIntSparseVectorStorage sparseStorage = (LongIntSparseVectorStorage) storage;\n+            long[] keys = sparseStorage.getIndices();\n+            int[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else {\n+            // Key and value array pair\n+            LongIntSortedVectorStorage sortStorage = (LongIntSortedVectorStorage) storage;\n+            long[] keys = sortStorage.getIndices();\n+            int[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n+\n+    public static KeyValuePart[] splitLongLongVector(MatrixMeta matrixMeta, LongLongVector vector) {\n+        LongLongVectorStorage storage = vector.getStorage();\n+        if (storage.isSparse()) {\n+            // Get keys and values\n+            LongLongSparseVectorStorage sparseStorage = (LongLongSparseVectorStorage) storage;\n+            long[] keys = sparseStorage.getIndices();\n+            long[] values = sparseStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, false);\n+        } else {\n+            // Key and value array pair\n+            LongLongSortedVectorStorage sortStorage = (LongLongSortedVectorStorage) storage;\n+            long[] keys = sortStorage.getIndices();\n+            long[] values = sortStorage.getValues();\n+            return split(matrixMeta, vector.getRowId(), keys, values, true);\n+        }\n+    }\n }\n",
            "diff_size": 819
        },
        {
            "tool": "naturalize",
            "violations": [
                {
                    "line": "143",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "158",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "177",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "192",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "210",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "223",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "241",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "273",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "286",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "304",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "322",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "341",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "357",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "375",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "390",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "408",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "441",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "455",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "473",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "479",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "483",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "487",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "491",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "495",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "499",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "520",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "538",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "556",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "574",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "592",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "758",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/320/RangeRouterUtils.java\nindex 1a354ff075b..6f6f0871890 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/320/RangeRouterUtils.java\n@@ -64,7 +64,7 @@ public class RangeRouterUtils {\n       Arrays.sort(keys);\n     }\n \n-    if(keys[keys.length - 1] >= matrixMeta.getColNum()) {\n+    if (keys[keys.length - 1] >= matrixMeta.getColNum()) {\n       System.out.println(\"Error happened!!!\");\n     }\n \n@@ -140,8 +140,7 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      boolean isSorted) {\n+  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n@@ -156,9 +155,8 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, float[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -176,10 +174,10 @@ public class RangeRouterUtils {\n       }\n \n       if (length != 0) {\n-        dataParts[partIndex] = new RangeViewIntKeysFloatValuesPart(rowId, keys, values,\n-            keyIndex - length, keyIndex);\n-      }\n-      partIndex++;\n+        dataParts[partIndex] = new RangeViewIntKeysFloatValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+  }\n+\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -191,9 +189,8 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, double[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -210,9 +207,8 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewIntKeysDoubleValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewIntKeysDoubleValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -224,9 +220,8 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      int[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, int[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -243,9 +238,8 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewIntKeysIntValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewIntKeysIntValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -258,8 +252,8 @@ public class RangeRouterUtils {\n    * @return partition key to key partition map\n    */\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values, boolean isSorted) {\n-    if (!isSorted) {\n+long[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -276,9 +270,8 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewIntKeysLongValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewIntKeysLongValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -290,9 +283,8 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, IElement[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -309,9 +301,8 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewIntKeysAnyValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewIntKeysAnyValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -328,9 +319,8 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, float[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -348,10 +338,10 @@ public class RangeRouterUtils {\n       }\n \n       if (length != 0) {\n-        dataParts[partIndex] = new RangeViewLongKeysFloatValuesPart(rowId, keys, values,\n-            keyIndex - length, keyIndex);\n-      }\n-      partIndex++;\n+        dataParts[partIndex] = new RangeViewLongKeysFloatValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+  }\n+\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -364,9 +354,8 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, double[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -383,9 +372,8 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewLongKeysDoubleValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewLongKeysDoubleValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -399,9 +387,8 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      int[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, int[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -418,9 +405,8 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewLongKeysIntValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewLongKeysIntValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -434,8 +420,8 @@ public class RangeRouterUtils {\n    * @return partition key to key partition map\n    */\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values, boolean isSorted) {\n-    if (!isSorted) {\n+long[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -452,9 +438,8 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewLongKeysLongValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewLongKeysLongValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n@@ -467,9 +452,8 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if (!isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, IElement[] values, boolean isSorted) {\n+  if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n@@ -486,40 +470,33 @@ public class RangeRouterUtils {\n         length++;\n       }\n \n-      dataParts[partIndex] = new RangeViewLongKeysAnyValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n-      partIndex++;\n+      dataParts[partIndex] = new RangeViewLongKeysAnyValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n+partIndex++;\n     }\n     return dataParts;\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      float[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, float[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      float[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, float[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      double[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, double[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      double[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, double[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      IElement[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, IElement[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      IElement[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, IElement[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n@@ -540,9 +517,8 @@ public class RangeRouterUtils {\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n \n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewDoubleValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n+      dataParts[i] = new RangeViewDoubleValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+  }\n     return dataParts;\n   }\n \n@@ -559,9 +535,8 @@ public class RangeRouterUtils {\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n \n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewFloatValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n+      dataParts[i] = new RangeViewFloatValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+  }\n     return dataParts;\n   }\n \n@@ -578,9 +553,8 @@ public class RangeRouterUtils {\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n \n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewIntValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n+      dataParts[i] = new RangeViewIntValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+  }\n     return dataParts;\n   }\n \n@@ -597,9 +571,8 @@ public class RangeRouterUtils {\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n \n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewLongValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n+      dataParts[i] = new RangeViewLongValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+  }\n     return dataParts;\n   }\n \n@@ -616,9 +589,8 @@ public class RangeRouterUtils {\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n \n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewAnyValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n-    }\n+      dataParts[i] = new RangeViewAnyValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+  }\n     return dataParts;\n   }\n \n@@ -634,33 +606,24 @@ public class RangeRouterUtils {\n       case T_DOUBLE_SPARSE:\n       case T_DOUBLE_DENSE:\n         return splitIntDoubleVector(matrixMeta, (IntDoubleVector) vector);\n-\n-      case T_FLOAT_SPARSE:\n+  case T_FLOAT_SPARSE:\n       case T_FLOAT_DENSE:\n         return splitIntFloatVector(matrixMeta, (IntFloatVector) vector);\n-\n-      case T_INT_DENSE:\n+  case T_INT_DENSE:\n       case T_INT_SPARSE:\n         return splitIntIntVector(matrixMeta, (IntIntVector) vector);\n-\n-      case T_LONG_DENSE:\n+  case T_LONG_DENSE:\n       case T_LONG_SPARSE:\n         return splitIntLongVector(matrixMeta, (IntLongVector) vector);\n-\n-      case T_DOUBLE_SPARSE_LONGKEY:\n+  case T_DOUBLE_SPARSE_LONGKEY:\n         return splitLongDoubleVector(matrixMeta, (LongDoubleVector) vector);\n-\n-      case T_FLOAT_SPARSE_LONGKEY:\n+  case T_FLOAT_SPARSE_LONGKEY:\n         return splitLongFloatVector(matrixMeta, (LongFloatVector) vector);\n-\n-      case T_INT_SPARSE_LONGKEY:\n+  case T_INT_SPARSE_LONGKEY:\n         return splitLongIntVector(matrixMeta, (LongIntVector) vector);\n-\n-      case T_LONG_SPARSE_LONGKEY:\n+  case T_LONG_SPARSE_LONGKEY:\n         return splitLongLongVector(matrixMeta, (LongLongVector) vector);\n-\n-\n-      default:\n+  default:\n         throw new UnsupportedOperationException(\"Unsupport vector type \" + vector.getType());\n     }\n   }\n@@ -859,4 +822,4 @@ public class RangeRouterUtils {\n       return split(matrixMeta, vector.getRowId(), keys, values, true);\n     }\n   }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 108
        },
        {
            "tool": "codebuff",
            "violations": [
                {
                    "line": "184",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "216",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "247",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "278",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "309",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "347",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "380",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "413",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "445",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "477",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "531",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "550",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "569",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "588",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "607",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "695",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 696.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "700",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 701.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "717",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 718.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "722",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 723.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "739",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 740.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "744",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 745.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "761",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 762.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "766",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 13, indentation should be the same level as line 767.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "774",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/320/RangeRouterUtils.java\nindex 1a354ff075b..eff6a755097 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/320/RangeRouterUtils.java\n@@ -59,18 +59,19 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n     if (!isSorted) {\n       Arrays.sort(keys);\n     }\n \n-    if(keys[keys.length - 1] >= matrixMeta.getColNum()) {\n+    if (keys[keys.length - 1] >= matrixMeta.getColNum()) {\n       System.out.println(\"Error happened!!!\");\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyPart[] dataParts = new KeyPart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -96,14 +97,15 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n     if (!isSorted) {\n       Arrays.sort(keys);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyPart[] dataParts = new KeyPart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -129,7 +131,9 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, boolean isSorted) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, String[] keys, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n   }\n \n@@ -140,8 +144,9 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      boolean isSorted) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n@@ -156,15 +161,15 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, float[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -176,8 +181,7 @@ public class RangeRouterUtils {\n       }\n \n       if (length != 0) {\n-        dataParts[partIndex] = new RangeViewIntKeysFloatValuesPart(rowId, keys, values,\n-            keyIndex - length, keyIndex);\n+        dataParts[partIndex] = new RangeViewIntKeysFloatValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       }\n       partIndex++;\n     }\n@@ -191,15 +195,15 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, double[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -209,9 +213,7 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysDoubleValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewIntKeysDoubleValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n@@ -224,15 +226,15 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      int[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, int[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -242,9 +244,7 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysIntValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewIntKeysIntValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n@@ -257,15 +257,15 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, long[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -275,9 +275,7 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysLongValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewIntKeysLongValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n@@ -290,15 +288,15 @@ public class RangeRouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, IElement[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -308,9 +306,7 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewIntKeysAnyValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewIntKeysAnyValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n@@ -328,15 +324,15 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, float[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -348,8 +344,7 @@ public class RangeRouterUtils {\n       }\n \n       if (length != 0) {\n-        dataParts[partIndex] = new RangeViewLongKeysFloatValuesPart(rowId, keys, values,\n-            keyIndex - length, keyIndex);\n+        dataParts[partIndex] = new RangeViewLongKeysFloatValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       }\n       partIndex++;\n     }\n@@ -364,15 +359,15 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, double[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -382,9 +377,7 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysDoubleValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewLongKeysDoubleValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n@@ -399,15 +392,15 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      int[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, int[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -417,9 +410,7 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysIntValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewLongKeysIntValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n@@ -433,15 +424,15 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, long[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -451,9 +442,7 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysLongValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewLongKeysLongValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n@@ -467,15 +456,15 @@ public class RangeRouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values, boolean isSorted) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, IElement[] values, boolean isSorted) {\n     if (!isSorted) {\n       Sort.quickSort(keys, values, 0, keys.length - 1);\n     }\n \n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     int keyIndex = 0;\n     int partIndex = 0;\n     while (keyIndex < keys.length || partIndex < matrixParts.length) {\n@@ -485,41 +474,39 @@ public class RangeRouterUtils {\n         keyIndex++;\n         length++;\n       }\n-\n-      dataParts[partIndex] = new RangeViewLongKeysAnyValuesPart(rowId, keys, values,\n-          keyIndex - length, keyIndex);\n+      dataParts[partIndex] = new RangeViewLongKeysAnyValuesPart(rowId, keys, values, keyIndex - length, keyIndex);\n       partIndex++;\n     }\n     return dataParts;\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      float[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, String[] keys, float[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      float[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] keys, float[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      double[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, String[] keys, double[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      double[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] keys, double[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      IElement[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, String[] keys, IElement[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport String key in range partition\");\n   }\n \n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      IElement[] values, boolean isSorted) {\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] keys, IElement[] values, boolean isSorted) {\n     throw new UnsupportedOperationException(\"Unsupport IElement key in range partition\");\n   }\n \n@@ -535,13 +522,13 @@ public class RangeRouterUtils {\n    * @param values values\n    * @return value splits\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, double[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, double[] values) {\n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewDoubleValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+      dataParts[i] = new RangeViewDoubleValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n     }\n     return dataParts;\n   }\n@@ -554,13 +541,13 @@ public class RangeRouterUtils {\n    * @param values values\n    * @return value splits\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, float[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, float[] values) {\n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewFloatValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+      dataParts[i] = new RangeViewFloatValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n     }\n     return dataParts;\n   }\n@@ -573,13 +560,13 @@ public class RangeRouterUtils {\n    * @param values values\n    * @return value splits\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] values) {\n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewIntValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+      dataParts[i] = new RangeViewIntValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n     }\n     return dataParts;\n   }\n@@ -592,13 +579,13 @@ public class RangeRouterUtils {\n    * @param values values\n    * @return value splits\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] values) {\n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewLongValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+      dataParts[i] = new RangeViewLongValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n     }\n     return dataParts;\n   }\n@@ -611,13 +598,13 @@ public class RangeRouterUtils {\n    * @param values values\n    * @return value splits\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] values) {\n     PartitionKey[] matrixParts = matrixMeta.getPartitionKeys();\n     KeyValuePart[] dataParts = new KeyValuePart[matrixParts.length];\n-\n     for (int i = 0; i < matrixParts.length; i++) {\n-      dataParts[i] = new RangeViewAnyValuesPart(rowId, values,\n-          (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n+      dataParts[i] = new RangeViewAnyValuesPart(rowId, values, (int) matrixParts[i].getStartCol(), (int) matrixParts[i].getEndCol());\n     }\n     return dataParts;\n   }\n@@ -629,37 +616,29 @@ public class RangeRouterUtils {\n    * @param vector Matrix vector\n    * @return partition key to key partition map\n    */\n+\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, Vector vector) {\n     switch (vector.getType()) {\n       case T_DOUBLE_SPARSE:\n       case T_DOUBLE_DENSE:\n         return splitIntDoubleVector(matrixMeta, (IntDoubleVector) vector);\n-\n       case T_FLOAT_SPARSE:\n       case T_FLOAT_DENSE:\n         return splitIntFloatVector(matrixMeta, (IntFloatVector) vector);\n-\n       case T_INT_DENSE:\n       case T_INT_SPARSE:\n         return splitIntIntVector(matrixMeta, (IntIntVector) vector);\n-\n       case T_LONG_DENSE:\n       case T_LONG_SPARSE:\n         return splitIntLongVector(matrixMeta, (IntLongVector) vector);\n-\n       case T_DOUBLE_SPARSE_LONGKEY:\n         return splitLongDoubleVector(matrixMeta, (LongDoubleVector) vector);\n-\n       case T_FLOAT_SPARSE_LONGKEY:\n         return splitLongFloatVector(matrixMeta, (LongFloatVector) vector);\n-\n       case T_INT_SPARSE_LONGKEY:\n         return splitLongIntVector(matrixMeta, (LongIntVector) vector);\n-\n       case T_LONG_SPARSE_LONGKEY:\n         return splitLongLongVector(matrixMeta, (LongLongVector) vector);\n-\n-\n       default:\n         throw new UnsupportedOperationException(\"Unsupport vector type \" + vector.getType());\n     }\n@@ -673,6 +652,7 @@ public class RangeRouterUtils {\n    * @param vector Matrix vector\n    * @return partition key to key partition map\n    */\n+\n   public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector vector) {\n     Vector[] vectors = new Vector[1];\n     vectors[0] = vector;\n@@ -686,10 +666,10 @@ public class RangeRouterUtils {\n    * @param vectors Matrix vectors\n    * @return partition key to key partition map\n    */\n+\n   public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector[] vectors) {\n     CompStreamKeyValuePart[] dataParts = new CompStreamKeyValuePart[matrixMeta.getPartitionNum()];\n     KeyValuePart[][] subDataParts = new KeyValuePart[vectors.length][];\n-\n     for (int i = 0; i < vectors.length; i++) {\n       subDataParts[i] = split(matrixMeta, vectors[i]);\n     }\n@@ -700,7 +680,6 @@ public class RangeRouterUtils {\n         dataParts[i].add(subDataParts[j][i]);\n       }\n     }\n-\n     return dataParts;\n   }\n \n@@ -714,15 +693,15 @@ public class RangeRouterUtils {\n       return split(matrixMeta, vector.getRowId(), keys, values, false);\n     } else if (storage.isDense()) {\n       // Get values\n-      IntDoubleDenseVectorStorage denseStorage = (IntDoubleDenseVectorStorage) storage;\n-      double[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n+             IntDoubleDenseVectorStorage denseStorage = (IntDoubleDenseVectorStorage) storage;\n+             double[] values = denseStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), values);\n     } else {\n       // Key and value array pair\n-      IntDoubleSortedVectorStorage sortStorage = (IntDoubleSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      double[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n+             IntDoubleSortedVectorStorage sortStorage = (IntDoubleSortedVectorStorage) storage;\n+             int[] keys = sortStorage.getIndices();\n+             double[] values = sortStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), keys, values, true);\n     }\n   }\n \n@@ -736,15 +715,15 @@ public class RangeRouterUtils {\n       return split(matrixMeta, vector.getRowId(), keys, values, false);\n     } else if (storage.isDense()) {\n       // Get values\n-      IntFloatDenseVectorStorage denseStorage = (IntFloatDenseVectorStorage) storage;\n-      float[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n+             IntFloatDenseVectorStorage denseStorage = (IntFloatDenseVectorStorage) storage;\n+             float[] values = denseStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), values);\n     } else {\n       // Key and value array pair\n-      IntFloatSortedVectorStorage sortStorage = (IntFloatSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      float[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n+             IntFloatSortedVectorStorage sortStorage = (IntFloatSortedVectorStorage) storage;\n+             int[] keys = sortStorage.getIndices();\n+             float[] values = sortStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), keys, values, true);\n     }\n   }\n \n@@ -758,15 +737,15 @@ public class RangeRouterUtils {\n       return split(matrixMeta, vector.getRowId(), keys, values, false);\n     } else if (storage.isDense()) {\n       // Get values\n-      IntIntDenseVectorStorage denseStorage = (IntIntDenseVectorStorage) storage;\n-      int[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n+             IntIntDenseVectorStorage denseStorage = (IntIntDenseVectorStorage) storage;\n+             int[] values = denseStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), values);\n     } else {\n       // Key and value array pair\n-      IntIntSortedVectorStorage sortStorage = (IntIntSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      int[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n+             IntIntSortedVectorStorage sortStorage = (IntIntSortedVectorStorage) storage;\n+             int[] keys = sortStorage.getIndices();\n+             int[] values = sortStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), keys, values, true);\n     }\n   }\n \n@@ -780,15 +759,15 @@ public class RangeRouterUtils {\n       return split(matrixMeta, vector.getRowId(), keys, values, false);\n     } else if (storage.isDense()) {\n       // Get values\n-      IntLongDenseVectorStorage denseStorage = (IntLongDenseVectorStorage) storage;\n-      long[] values = denseStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), values);\n+             IntLongDenseVectorStorage denseStorage = (IntLongDenseVectorStorage) storage;\n+             long[] values = denseStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), values);\n     } else {\n       // Key and value array pair\n-      IntLongSortedVectorStorage sortStorage = (IntLongSortedVectorStorage) storage;\n-      int[] keys = sortStorage.getIndices();\n-      long[] values = sortStorage.getValues();\n-      return split(matrixMeta, vector.getRowId(), keys, values, true);\n+             IntLongSortedVectorStorage sortStorage = (IntLongSortedVectorStorage) storage;\n+             int[] keys = sortStorage.getIndices();\n+             long[] values = sortStorage.getValues();\n+             return split(matrixMeta, vector.getRowId(), keys, values, true);\n     }\n   }\n \n@@ -859,4 +838,5 @@ public class RangeRouterUtils {\n       return split(matrixMeta, vector.getRowId(), keys, values, true);\n     }\n   }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 169
        },
        {
            "tool": "styler_random",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/random/files-repaired/320/RangeRouterUtils.java\nindex 1a354ff075b..c1a5bba1489 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/random/files-repaired/320/RangeRouterUtils.java\n@@ -792,8 +792,9 @@ public class RangeRouterUtils {\n     }\n   }\n \n-  public static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta, LongDoubleVector vector) {\n-    LongDoubleVectorStorage storage = vector.getStorage();\n+  public\n+  static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta, LongDoubleVector vector) {\n+     LongDoubleVectorStorage storage = vector.getStorage();\n     if (storage.isSparse()) {\n       // Get keys and values\n       LongDoubleSparseVectorStorage sparseStorage = (LongDoubleSparseVectorStorage) storage;\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/three_grams/files-repaired/320/RangeRouterUtils.java\nindex 1a354ff075b..74d9d1faa19 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/320/RangeRouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/three_grams/files-repaired/320/RangeRouterUtils.java\n@@ -792,8 +792,9 @@ public class RangeRouterUtils {\n     }\n   }\n \n-  public static KeyValuePart[] splitLongDoubleVector(MatrixMeta matrixMeta, LongDoubleVector vector) {\n-    LongDoubleVectorStorage storage = vector.getStorage();\n+  public static KeyValuePart[\n+      ] splitLongDoubleVector( MatrixMeta matrixMeta, LongDoubleVector vector)\n+  { LongDoubleVectorStorage storage = vector.getStorage();\n     if (storage.isSparse()) {\n       // Get keys and values\n       LongDoubleSparseVectorStorage sparseStorage = (LongDoubleSparseVectorStorage) storage;\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "checkstyle_idea",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}