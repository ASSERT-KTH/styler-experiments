{
    "project_name": "TIBCOSoftware-genxdm",
    "violation_id": "240",
    "information": {
        "violations": [
            {
                "line": "32",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class IdentityScopeRef extends IdentityScope\n{\n\tprivate final IdentityScopeKey keyScope;\n\n\tpublic IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n\t{",
    "results": [
        {
            "tool": "styler",
            "violations": [
                {
                    "line": "34",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/./experiments/projects/TIBCOSoftware-genxdm/styler/05_predictions/final/files-repaired/240/IdentityScopeRef.java\nindex 36965bd8d4d..82acaa9b241 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/./experiments/projects/TIBCOSoftware-genxdm/styler/05_predictions/final/files-repaired/240/IdentityScopeRef.java\n@@ -29,7 +29,7 @@ import org.genxdm.xs.resolve.LocationInSchema;\n  */\n final class IdentityScopeRef extends IdentityScope\n {\n-\tprivate final IdentityScopeKey keyScope;\n+private final IdentityScopeKey keyScope;\n \n \tpublic IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "checkstyle_idea",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/checkstyle_idea/240/IdentityScopeRef.java\nindex 36965bd8d4d..99a70779a65 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/checkstyle_idea/240/IdentityScopeRef.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.util.ArrayList;\n@@ -27,66 +28,59 @@ import org.genxdm.xs.resolve.LocationInSchema;\n /**\n  * Specialization of a scope for xs:keyref.\n  */\n-final class IdentityScopeRef extends IdentityScope\n-{\n-\tprivate final IdentityScopeKey keyScope;\n+final class IdentityScopeRef extends IdentityScope {\n+    private final IdentityScopeKey keyScope;\n \n-\tpublic IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n-\t{\n-\t\tsuper(elementIndex, constraint, errorHandler, location);\n-\t\tthis.keyScope = keyScope;\n-\t}\n+    public IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope,\n+                            final IdentityConstraint constraint,\n+                            final SchemaExceptionHandler errorHandler,\n+                            final LocationInSchema location) {\n+        super(elementIndex, constraint, errorHandler, location);\n+        this.keyScope = keyScope;\n+    }\n \n-\t@Override\n-\tprotected void onKeysComplete(final ArrayList<IdentityKey> keyValues, final int elementIndex) throws AbortException\n-\t{\n-\t\tfinal IdentityTuple key = new IdentityTuple(keyValues);\n+    @Override\n+    protected void onKeysComplete(final ArrayList<IdentityKey> keyValues, final int elementIndex)\n+        throws AbortException {\n+        final IdentityTuple key = new IdentityTuple(keyValues);\n \n-\t\tfinal IdentityVariant lookup = keyScope.m_qualifiedTargets.get(key);\n+        final IdentityVariant lookup = keyScope.m_qualifiedTargets.get(key);\n \n-\t\tif (lookup == null)\n-\t\t{\n-\t\t\tfinal ArrayList<IdentityDanglingReference> dangles = new ArrayList<IdentityDanglingReference>();\n-\t\t\tdangles.add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n-\t\t\tkeyScope.m_qualifiedTargets.put(key, new IdentityVariant(dangles));\n-\t\t}\n-\t\telse if (lookup.isValue())\n-\t\t{\n-\t\t\t// The corresponding key has already been found.\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tlookup.getDanglingRefs().add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n-\t\t}\n-\t}\n+        if (lookup == null) {\n+            final ArrayList<IdentityDanglingReference> dangles =\n+                new ArrayList<IdentityDanglingReference>();\n+            dangles.add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n+            keyScope.m_qualifiedTargets.put(key, new IdentityVariant(dangles));\n+        } else if (lookup.isValue()) {\n+            // The corresponding key has already been found.\n+        } else {\n+            lookup.getDanglingRefs()\n+                .add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n+        }\n+    }\n \n-\t@Override\n-\tprotected void onScopeEnd(final int elementIndex, final Locatable locatable)\n-\t{\n-\t\t// Do nothing.\n-\t}\n+    @Override\n+    protected void onScopeEnd(final int elementIndex, final Locatable locatable) {\n+        // Do nothing.\n+    }\n \n-\t/**\n-\t * This method should only be called on scopes that correspond to xs:keyref.\n-\t */\n-\tpublic void reportUnmatchedRefs() throws AbortException\n-\t{\n-\t\tfor (final IdentityVariant next : keyScope.m_qualifiedTargets.values())\n-\t\t{\n-\t\t\tif (next.isDanglingRefs())\n-\t\t\t{\n-\t\t\t\tfor (final IdentityDanglingReference dangling : next.getDanglingRefs())\n-\t\t\t\t{\n-\t\t\t\t\tfinal CvcDanglingKeyReferenceException dkre = new CvcDanglingKeyReferenceException(dangling.getConstraint().getName(), dangling.getKeys(), m_location);\n-\t\t\t\t\tm_errorHandler.error(dkre);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// The polymorphic type of the identity variant is a\n-\t\t\t\t// Boolean.TRUE\n-\t\t\t\t// which indicates that there are no dangling references.\n-\t\t\t}\n-\t\t}\n-\t}\n+    /**\n+     * This method should only be called on scopes that correspond to xs:keyref.\n+     */\n+    public void reportUnmatchedRefs() throws AbortException {\n+        for (final IdentityVariant next : keyScope.m_qualifiedTargets.values()) {\n+            if (next.isDanglingRefs()) {\n+                for (final IdentityDanglingReference dangling : next.getDanglingRefs()) {\n+                    final CvcDanglingKeyReferenceException dkre =\n+                        new CvcDanglingKeyReferenceException(dangling.getConstraint().getName(),\n+                            dangling.getKeys(), m_location);\n+                    m_errorHandler.error(dkre);\n+                }\n+            } else {\n+                // The polymorphic type of the identity variant is a\n+                // Boolean.TRUE\n+                // which indicates that there are no dangling references.\n+            }\n+        }\n+    }\n }\n",
            "diff_size": 63
        },
        {
            "tool": "naturalize",
            "violations": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/codebuff/240/IdentityScopeRef.java\nindex 36965bd8d4d..bf96f693ffa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/codebuff/240/IdentityScopeRef.java\n@@ -16,7 +16,6 @@\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.util.ArrayList;\n-\n import org.genxdm.processor.w3c.xs.exception.cvc.CvcDanglingKeyReferenceException;\n import org.genxdm.xs.constraints.IdentityConstraint;\n import org.genxdm.xs.exceptions.AbortException;\n@@ -27,66 +26,74 @@ import org.genxdm.xs.resolve.LocationInSchema;\n /**\n  * Specialization of a scope for xs:keyref.\n  */\n+\n final class IdentityScopeRef extends IdentityScope\n {\n-\tprivate final IdentityScopeKey keyScope;\n+    private final IdentityScopeKey keyScope;\n+\n+    public IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n+    {\n+        super(elementIndex, constraint, errorHandler, location);\n+        this.keyScope = keyScope;\n+    }\n+\n+    @Override\n+    protected void onKeysComplete(final ArrayList<IdentityKey> keyValues, final int elementIndex)\n+        throws AbortException\n+    {\n+        final IdentityTuple key = new IdentityTuple(keyValues);\n+        final IdentityVariant lookup = keyScope.m_qualifiedTargets.get(key);\n+        if (lookup == null)\n+        {\n+            final ArrayList<IdentityDanglingReference> dangles = new ArrayList<IdentityDanglingReference>();\n+            dangles.add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n+            keyScope.m_qualifiedTargets.put(key, new IdentityVariant(dangles));\n+        }\n+        else if (lookup.isValue())\n+        {\n+            // The corresponding key has already been found.\n+\n+        }\n+        else\n+        {\n+            lookup.getDanglingRefs().add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n+        }\n+    }\n \n-\tpublic IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n-\t{\n-\t\tsuper(elementIndex, constraint, errorHandler, location);\n-\t\tthis.keyScope = keyScope;\n-\t}\n+    @Override\n+    protected void onScopeEnd(final int elementIndex, final Locatable locatable)\n+    {\n+        // Do nothing.\n \n-\t@Override\n-\tprotected void onKeysComplete(final ArrayList<IdentityKey> keyValues, final int elementIndex) throws AbortException\n-\t{\n-\t\tfinal IdentityTuple key = new IdentityTuple(keyValues);\n \n-\t\tfinal IdentityVariant lookup = keyScope.m_qualifiedTargets.get(key);\n+    }\n \n-\t\tif (lookup == null)\n-\t\t{\n-\t\t\tfinal ArrayList<IdentityDanglingReference> dangles = new ArrayList<IdentityDanglingReference>();\n-\t\t\tdangles.add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n-\t\t\tkeyScope.m_qualifiedTargets.put(key, new IdentityVariant(dangles));\n-\t\t}\n-\t\telse if (lookup.isValue())\n-\t\t{\n-\t\t\t// The corresponding key has already been found.\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tlookup.getDanglingRefs().add(new IdentityDanglingReference(getConstraint(), keyValues, m_location));\n-\t\t}\n-\t}\n+    /**\n+     * This method should only be called on scopes that correspond to xs:keyref.\n+     */\n \n-\t@Override\n-\tprotected void onScopeEnd(final int elementIndex, final Locatable locatable)\n-\t{\n-\t\t// Do nothing.\n-\t}\n+    public void reportUnmatchedRefs()\n+        throws AbortException\n+    {\n+        for (final IdentityVariant next : keyScope.m_qualifiedTargets.values())\n+        {\n+            if (next.isDanglingRefs())\n+            {\n+                for (final IdentityDanglingReference dangling : next.getDanglingRefs())\n+                {\n+                    final CvcDanglingKeyReferenceException dkre = new CvcDanglingKeyReferenceException(dangling.getConstraint().getName(),\n+                        dangling.getKeys(),\n+                            m_location);\n+                    m_errorHandler.error(dkre);\n+                }\n+            }\n+            else\n+            {\n+                // The polymorphic type of the identity variant is a\n+                // Boolean.TRUE\n+                // which indicates that there are no dangling references.\n \n-\t/**\n-\t * This method should only be called on scopes that correspond to xs:keyref.\n-\t */\n-\tpublic void reportUnmatchedRefs() throws AbortException\n-\t{\n-\t\tfor (final IdentityVariant next : keyScope.m_qualifiedTargets.values())\n-\t\t{\n-\t\t\tif (next.isDanglingRefs())\n-\t\t\t{\n-\t\t\t\tfor (final IdentityDanglingReference dangling : next.getDanglingRefs())\n-\t\t\t\t{\n-\t\t\t\t\tfinal CvcDanglingKeyReferenceException dkre = new CvcDanglingKeyReferenceException(dangling.getConstraint().getName(), dangling.getKeys(), m_location);\n-\t\t\t\t\tm_errorHandler.error(dkre);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// The polymorphic type of the identity variant is a\n-\t\t\t\t// Boolean.TRUE\n-\t\t\t\t// which indicates that there are no dangling references.\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 101
        },
        {
            "tool": "styler_random",
            "violations": [
                {
                    "line": "34",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/styler/05_predictions/random/files-repaired/240/IdentityScopeRef.java\nindex 36965bd8d4d..82acaa9b241 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/styler/05_predictions/random/files-repaired/240/IdentityScopeRef.java\n@@ -29,7 +29,7 @@ import org.genxdm.xs.resolve.LocationInSchema;\n  */\n final class IdentityScopeRef extends IdentityScope\n {\n-\tprivate final IdentityScopeKey keyScope;\n+private final IdentityScopeKey keyScope;\n \n \tpublic IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "violations": [
                {
                    "line": "34",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/styler/05_predictions/three_grams/files-repaired/240/IdentityScopeRef.java\nindex 36965bd8d4d..209f564080c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/violations/240/IdentityScopeRef.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/TIBCOSoftware-genxdm/styler/05_predictions/three_grams/files-repaired/240/IdentityScopeRef.java\n@@ -29,7 +29,7 @@ import org.genxdm.xs.resolve.LocationInSchema;\n  */\n final class IdentityScopeRef extends IdentityScope\n {\n-\tprivate final IdentityScopeKey keyScope;\n+    private final IdentityScopeKey keyScope;\n \n \tpublic IdentityScopeRef(final int elementIndex, final IdentityScopeKey keyScope, final IdentityConstraint constraint, final SchemaExceptionHandler errorHandler, final LocationInSchema location)\n \t{\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "checkstyle_idea",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}