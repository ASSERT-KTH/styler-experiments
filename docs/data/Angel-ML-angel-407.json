{
    "project_name": "Angel-ML-angel",
    "violation_id": "407",
    "information": {
        "violations": [
            {
                "line": "112",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "   * @return partition key to key partition map\n   */\n  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n    if(matrixMeta.isHash()) {\n      return HashRouterUtils.split(matrixMeta, rowId, keys);\n    } else {",
    "results": [
        {
            "tool": "styler",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/./experiments/projects/Angel-ML-angel/styler/05_predictions/final/files-repaired/407/RouterUtils.java\nindex 8bdb804a736..370570fa4dd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/./experiments/projects/Angel-ML-angel/styler/05_predictions/final/files-repaired/407/RouterUtils.java\n@@ -109,7 +109,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n+  public static KeyPart[] split( MatrixMeta matrixMeta, int rowId, IElement\n+    [ ] keys, boolean isSorted) {\n     if(matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys);\n     } else {\n",
            "diff_size": 2
        },
        {
            "tool": "checkstyle_idea",
            "violations": [
                {
                    "line": "12",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "122",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "124",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "186",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "188",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "248",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "250",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "311",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "313",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "401",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "403",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/407/RouterUtils.java\nindex 8bdb804a736..6d70b5d0bb7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/407/RouterUtils.java\n@@ -9,450 +9,452 @@ import com.tencent.angel.psagent.matrix.transport.router.range.RangeRouterUtils;\n \n public class RouterUtils {\n \n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-  // Keys split\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys) {\n-    return split(matrixMeta, rowId, keys, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys) {\n-    return split(matrixMeta, rowId, keys, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys) {\n-    return split(matrixMeta, rowId, keys, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys) {\n-    return split(matrixMeta, rowId, keys, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+    // Keys split\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys) {\n+        return split(matrixMeta, rowId, keys, false);\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys) {\n+        return split(matrixMeta, rowId, keys, false);\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys) {\n+        return split(matrixMeta, rowId, keys, false);\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys) {\n+        return split(matrixMeta, rowId, keys, false);\n     }\n-  }\n-\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-  // Keys and values split: int/long/string/object key, float value\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+        }\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+        }\n     }\n-  }\n-\n-\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-  // Keys and values split: int/long/string/object key, double value\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n+                                  boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+        }\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n+                                  boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n+        }\n     }\n-  }\n-\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-  // Keys and values split: int/long/string/object key, long value\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+    // Keys and values split: int/long/string/object key, float value\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       float[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       float[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n     }\n-  }\n-\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-  // Keys and values split: int/long/string/object key, object value\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n-  }\n-\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       float[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       float[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      IElement[] values) {\n-    return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-  }\n-\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param keys the keys need partitioned\n-   * @param values the values of the keys\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      IElement[] values) {\n-    return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n-  }\n-\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-  // Keys and values split: vector\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param vector Matrix vector\n-   * @return partition key to key partition map\n-   */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, Vector vector) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.split(matrixMeta, vector);\n-    } else {\n-      return RangeRouterUtils.split(matrixMeta, vector);\n+\n+\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+    // Keys and values split: int/long/string/object key, double value\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       double[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       double[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       double[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       double[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n+    }\n+\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+    // Keys and values split: int/long/string/object key, long value\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       long[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param vector Matrix vector\n-   * @return partition key to key partition map\n-   */\n-  public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector vector) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.splitStream(matrixMeta, vector);\n-    } else {\n-      return RangeRouterUtils.splitStream(matrixMeta, vector);\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       long[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n     }\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param matrix Matrix vector\n-   * @return partition key to key partition map\n-   */\n-  public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Matrix matrix) {\n-    return null;\n-  }\n-\n-  /**\n-   * Split keys by matrix partition\n-   *\n-   * @param matrixMeta matrix meta data\n-   * @param vectors Matrix vector\n-   * @return partition key to key partition map\n-   */\n-  public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector[] vectors) {\n-    if(matrixMeta.isHash()) {\n-      return HashRouterUtils.splitStream(matrixMeta, vectors);\n-    } else {\n-      return RangeRouterUtils.splitStream(matrixMeta, vectors);\n+\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       long[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       long[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n+    }\n+\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+    // Keys and values split: int/long/string/object key, object value\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       IElement[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       IElement[] values) {\n+        return split(matrixMeta, rowId, keys, values, false);\n+    }\n+\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n+                                       IElement[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n+                                       IElement[] values, boolean isSorted) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n+        }\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n+                                       IElement[] values) {\n+        return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+    }\n+\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param keys       the keys need partitioned\n+     * @param values     the values of the keys\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n+                                       IElement[] values) {\n+        return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+    }\n+\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+    // Keys and values split: vector\n+    //////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param vector     Matrix vector\n+     * @return partition key to key partition map\n+     */\n+    public static KeyValuePart[] split(MatrixMeta matrixMeta, Vector vector) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.split(matrixMeta, vector);\n+        } else {\n+            return RangeRouterUtils.split(matrixMeta, vector);\n+        }\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param vector     Matrix vector\n+     * @return partition key to key partition map\n+     */\n+    public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector vector) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.splitStream(matrixMeta, vector);\n+        } else {\n+            return RangeRouterUtils.splitStream(matrixMeta, vector);\n+        }\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param matrix     Matrix vector\n+     * @return partition key to key partition map\n+     */\n+    public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Matrix matrix) {\n+        return null;\n+    }\n+\n+    /**\n+     * Split keys by matrix partition\n+     *\n+     * @param matrixMeta matrix meta data\n+     * @param vectors    Matrix vector\n+     * @return partition key to key partition map\n+     */\n+    public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector[] vectors) {\n+        if (matrixMeta.isHash()) {\n+            return HashRouterUtils.splitStream(matrixMeta, vectors);\n+        } else {\n+            return RangeRouterUtils.splitStream(matrixMeta, vectors);\n+        }\n     }\n-  }\n }\n",
            "diff_size": 622
        },
        {
            "tool": "naturalize",
            "violations": [
                {
                    "line": "112",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "143",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "155",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "171",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "179",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 0, expected is 2, indentation should be the same level as line 190.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "190",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "202",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "213",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "229",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "311",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "323",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "335",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "351",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "367",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "380",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/407/RouterUtils.java\nindex 8bdb804a736..a7ede51f3b7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/407/RouterUtils.java\n@@ -128,9 +128,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, float[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n   /**\n@@ -141,9 +140,8 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, float[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n \n@@ -154,9 +152,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, float[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -171,17 +168,15 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, float[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n     }\n   }\n \n-\n-  //////////////////////////////////////////////////////////////////////////////////////////////////\n+//////////////////////////////////////////////////////////////////////////////////////////////////\n   // Keys and values split: int/long/string/object key, double value\n   //////////////////////////////////////////////////////////////////////////////////////////////////\n \n@@ -192,9 +187,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, double[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n   /**\n@@ -205,9 +199,8 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, double[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n   /**\n@@ -217,9 +210,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, double[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -234,9 +226,8 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, double[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -255,8 +246,8 @@ public class RouterUtils {\n    * @return partition key to key partition map\n    */\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+long[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n   /**\n@@ -268,8 +259,8 @@ public class RouterUtils {\n    * @return partition key to key partition map\n    */\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+long[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n \n@@ -281,8 +272,8 @@ public class RouterUtils {\n    * @return partition key to key partition map\n    */\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+long[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -298,8 +289,8 @@ public class RouterUtils {\n    * @return partition key to key partition map\n    */\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+long[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -317,9 +308,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, IElement[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n   /**\n@@ -330,9 +320,8 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values) {\n-    return split(matrixMeta, rowId, keys, values, false);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, IElement[] values) {\n+  return split(matrixMeta, rowId, keys, values, false);\n   }\n \n \n@@ -343,9 +332,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, IElement[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -360,9 +348,8 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, IElement[] values, boolean isSorted) {\n+  if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -377,9 +364,8 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      IElement[] values) {\n-    return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, IElement[] values) {\n+  return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n   }\n \n \n@@ -391,9 +377,8 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      IElement[] values) {\n-    return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n+  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, IElement[] values) {\n+  return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n   }\n \n   //////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -455,4 +440,4 @@ public class RouterUtils {\n       return RangeRouterUtils.splitStream(matrixMeta, vectors);\n     }\n   }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 53
        },
        {
            "tool": "codebuff",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/407/RouterUtils.java\nindex 8bdb804a736..96024b06d0a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/407/RouterUtils.java\n@@ -20,7 +20,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys) {\n     return split(matrixMeta, rowId, keys, false);\n   }\n \n@@ -31,7 +33,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys) {\n     return split(matrixMeta, rowId, keys, false);\n   }\n \n@@ -42,7 +46,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, String[] keys) {\n     return split(matrixMeta, rowId, keys, false);\n   }\n \n@@ -53,7 +59,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] keys) {\n     return split(matrixMeta, rowId, keys, false);\n   }\n \n@@ -64,8 +72,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n@@ -79,8 +89,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n@@ -94,8 +106,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, String[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, String[] keys, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n@@ -109,8 +123,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyPart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n@@ -128,8 +144,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, float[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -141,8 +158,9 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, float[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -154,9 +172,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      float[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, float[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -171,9 +190,10 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      float[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, float[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -192,8 +212,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, double[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -205,8 +226,9 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, double[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -217,9 +239,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      double[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, double[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -234,9 +257,10 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      double[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, double[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -254,8 +278,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, long[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -267,8 +292,9 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, long[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -280,9 +306,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      long[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, long[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -297,9 +324,10 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      long[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, long[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -317,8 +345,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, IElement[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -330,8 +359,9 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, IElement[] values) {\n     return split(matrixMeta, rowId, keys, values, false);\n   }\n \n@@ -343,9 +373,10 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, int[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, int[] keys, IElement[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -360,9 +391,10 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, long[] keys,\n-      IElement[] values, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, long[] keys, IElement[] values, boolean isSorted) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, values, isSorted);\n@@ -377,8 +409,9 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, String[] keys,\n-      IElement[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, String[] keys, IElement[] values) {\n     return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n   }\n \n@@ -391,8 +424,9 @@ public class RouterUtils {\n    * @param values the values of the keys\n    * @return partition key to key partition map\n    */\n-  public static KeyValuePart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys,\n-      IElement[] values) {\n+\n+  public static KeyValuePart[] split(\n+    MatrixMeta matrixMeta, int rowId, IElement[] keys, IElement[] values) {\n     return HashRouterUtils.split(matrixMeta, rowId, keys, values);\n   }\n \n@@ -407,8 +441,9 @@ public class RouterUtils {\n    * @param vector Matrix vector\n    * @return partition key to key partition map\n    */\n+\n   public static KeyValuePart[] split(MatrixMeta matrixMeta, Vector vector) {\n-    if(matrixMeta.isHash()) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, vector);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, vector);\n@@ -422,8 +457,9 @@ public class RouterUtils {\n    * @param vector Matrix vector\n    * @return partition key to key partition map\n    */\n+\n   public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector vector) {\n-    if(matrixMeta.isHash()) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.splitStream(matrixMeta, vector);\n     } else {\n       return RangeRouterUtils.splitStream(matrixMeta, vector);\n@@ -437,6 +473,7 @@ public class RouterUtils {\n    * @param matrix Matrix vector\n    * @return partition key to key partition map\n    */\n+\n   public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Matrix matrix) {\n     return null;\n   }\n@@ -448,11 +485,13 @@ public class RouterUtils {\n    * @param vectors Matrix vector\n    * @return partition key to key partition map\n    */\n+\n   public static CompStreamKeyValuePart[] splitStream(MatrixMeta matrixMeta, Vector[] vectors) {\n-    if(matrixMeta.isHash()) {\n+    if (matrixMeta.isHash()) {\n       return HashRouterUtils.splitStream(matrixMeta, vectors);\n     } else {\n       return RangeRouterUtils.splitStream(matrixMeta, vectors);\n     }\n   }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 99
        },
        {
            "tool": "styler_random",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/random/files-repaired/407/RouterUtils.java\nindex 8bdb804a736..370570fa4dd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/random/files-repaired/407/RouterUtils.java\n@@ -109,7 +109,8 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n+  public static KeyPart[] split( MatrixMeta matrixMeta, int rowId, IElement\n+    [ ] keys, boolean isSorted) {\n     if(matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys);\n     } else {\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "violations": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/three_grams/files-repaired/407/RouterUtils.java\nindex 8bdb804a736..41ddb7fcbdb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/407/RouterUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/styler/05_predictions/three_grams/files-repaired/407/RouterUtils.java\n@@ -109,8 +109,9 @@ public class RouterUtils {\n    * @param keys the keys need partitioned\n    * @return partition key to key partition map\n    */\n-  public static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n-    if(matrixMeta.isHash()) {\n+  public\n+  static KeyPart[] split(MatrixMeta matrixMeta, int rowId, IElement[] keys, boolean isSorted) {\n+     if(matrixMeta.isHash()) {\n       return HashRouterUtils.split(matrixMeta, rowId, keys);\n     } else {\n       return RangeRouterUtils.split(matrixMeta, rowId, keys, isSorted);\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "checkstyle_idea",
        "naturalize"
    ]
}