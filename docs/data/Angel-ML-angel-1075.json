{
    "project_name": "Angel-ML-angel",
    "violation_id": "1075",
    "information": {
        "violations": [
            {
                "line": "11",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 103).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * https://opensource.org/licenses/BSD-3-Clause\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language governing permissions and\n * limitations under the License.",
    "results": [
        {
            "tool": "styler",
            "violations": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "checkstyle_idea",
            "violations": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "206",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/1075/ModelParse.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/1075/ModelParse.java\nindex 56d79ac3856..d2b730b201b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/1075/ModelParse.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/1075/ModelParse.java\n@@ -32,311 +32,327 @@ import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n public class ModelParse {\n-  private static final Log LOG = LogFactory.getLog(ModelParse.class);\n-  private ExecutorService convertTaskPool;\n-  private static FileSystem infs;\n-  private static FileStatus[] fileStatus = null;\n-  private int[] indics;\n-  private AtomicBoolean isConverting = new AtomicBoolean(false);\n-  private String inputStr;\n-  private String modelName;\n-  private String outputStr;\n-  private Path outputPath;\n-  private int convertThreadCount;\n-  private Boolean type;// true-dense;false-sparse;\n+    private static final Log LOG = LogFactory.getLog(ModelParse.class);\n+    private ExecutorService convertTaskPool;\n+    private static FileSystem infs;\n+    private static FileStatus[] fileStatus = null;\n+    private int[] indics;\n+    private AtomicBoolean isConverting = new AtomicBoolean(false);\n+    private String inputStr;\n+    private String modelName;\n+    private String outputStr;\n+    private Path outputPath;\n+    private int convertThreadCount;\n+    private Boolean type;// true-dense;false-sparse;\n \n \n-  public ModelParse(String inputStr, String outputStr, String modelName, int convertThreadCount) {\n-    this.inputStr = inputStr;\n-    this.outputStr = outputStr;\n-    this.modelName = modelName;\n-    this.convertThreadCount = convertThreadCount;\n-  }\n+    public ModelParse(String inputStr, String outputStr, String modelName, int convertThreadCount) {\n+        this.inputStr = inputStr;\n+        this.outputStr = outputStr;\n+        this.modelName = modelName;\n+        this.convertThreadCount = convertThreadCount;\n+    }\n \n-  public class ConvertTask implements Runnable {\n+    public class ConvertTask implements Runnable {\n \n-    private FileStatus status;\n-    private AtomicBoolean isSuccess = new AtomicBoolean(false);\n-    private AtomicBoolean finishFlag = new AtomicBoolean(false);\n-    private String errorLog;\n-    private FSDataOutputStream out;\n+        private FileStatus status;\n+        private AtomicBoolean isSuccess = new AtomicBoolean(false);\n+        private AtomicBoolean finishFlag = new AtomicBoolean(false);\n+        private String errorLog;\n+        private FSDataOutputStream out;\n \n-    public ConvertTask(FileStatus status, FSDataOutputStream out) {\n-      this.status = status;\n-      this.out = out;\n-    }\n+        public ConvertTask(FileStatus status, FSDataOutputStream out) {\n+            this.status = status;\n+            this.out = out;\n+        }\n \n-    @Override\n-    public void run() {\n-      long startTime = Time.monotonicNow();\n-      LOG.info(\"open file \" + status.getPath());\n-      try {\n-        FSDataInputStream fin;\n-        fin = infs.open(status.getPath());\n-        int matrixId = fin.readInt();\n-        out.writeBytes(\"matrixId:\" + matrixId + \"\\n\");\n-        int partSize = fin.readInt();\n-        out.writeBytes(\"partSize:\" + partSize + \"\\n\");\n+        @Override\n+        public void run() {\n+            long startTime = Time.monotonicNow();\n+            LOG.info(\"open file \" + status.getPath());\n+            try {\n+                FSDataInputStream fin;\n+                fin = infs.open(status.getPath());\n+                int matrixId = fin.readInt();\n+                out.writeBytes(\"matrixId:\" + matrixId + \"\\n\");\n+                int partSize = fin.readInt();\n+                out.writeBytes(\"partSize:\" + partSize + \"\\n\");\n \n-        // read partition header\n-        int startRow = fin.readInt();\n-        int startCol = fin.readInt();\n-        int endRow = fin.readInt();\n-        int endCol = fin.readInt();\n-        String rowType = fin.readUTF();\n-        String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \"\n-                + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n-        out.writeBytes(patInfo + \"\\n\");\n-        LOG.info(patInfo);\n+                // read partition header\n+                int startRow = fin.readInt();\n+                int startCol = fin.readInt();\n+                int endRow = fin.readInt();\n+                int endCol = fin.readInt();\n+                String rowType = fin.readUTF();\n+                String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \"\n+                        + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n+                out.writeBytes(patInfo + \"\\n\");\n+                LOG.info(patInfo);\n \n-        int rowNum = fin.readInt();\n-        LOG.info(\"rowNum=\" + rowNum);\n-        out.writeBytes(\"rowNum:\" + rowNum + \"\\n\");\n-        int rowIndex;\n-        int rowLen;\n-        int startPos;\n-        int clock;\n+                int rowNum = fin.readInt();\n+                LOG.info(\"rowNum=\" + rowNum);\n+                out.writeBytes(\"rowNum:\" + rowNum + \"\\n\");\n+                int rowIndex;\n+                int rowLen;\n+                int startPos;\n+                int clock;\n \n-        switch (rowType) {\n-          case \"T_DOUBLE_SPARSE\": {\n-            type = false;\n-            int key;\n-            double value;\n-            for (int j = 0; j < rowNum; j++) {\n-              rowIndex = fin.readInt();\n-              clock = fin.readInt();\n-              rowLen = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n-              for (int k = 0; k < rowLen; k++) {\n-                key = fin.readInt();\n-                value = fin.readDouble();\n-                out.writeBytes(key + \":\" + value + \" \");\n-              }\n-              out.writeBytes(\"\\n\");\n-            }\n-            break;\n-          }\n+                switch (rowType) {\n+                    case \"T_DOUBLE_SPARSE\": {\n+                        type = false;\n+                        int key;\n+                        double value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            rowIndex = fin.readInt();\n+                            clock = fin.readInt();\n+                            rowLen = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen +\n+                                            \"\\n\");\n+                            for (int k = 0; k < rowLen; k++) {\n+                                key = fin.readInt();\n+                                value = fin.readDouble();\n+                                out.writeBytes(key + \":\" + value + \" \");\n+                            }\n+                            out.writeBytes(\"\\n\");\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_DOUBLE_DENSE\": {\n-            byte[] data = new byte[8 * (endCol - startCol)];\n-            rowLen = endCol - startCol;\n-            double value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              DoubleBuffer dBuffer = ByteBuffer.wrap(data, 0, data.length).asDoubleBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = dBuffer.get();\n-                out.writeBytes(value + \" \");\n-                // if (k < 10) {\n-                // LOG.info(\"resultArray: \" + vectorArray[startPos + k]);\n-                // }\n-              }\n-              out.writeBytes(\"\\n\");\n-            }\n-            break;\n-          }\n+                    case \"T_DOUBLE_DENSE\": {\n+                        byte[] data = new byte[8 * (endCol - startCol)];\n+                        rowLen = endCol - startCol;\n+                        double value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                            \"\\n\");\n+                            fin.read(data, 0, data.length);\n+                            DoubleBuffer dBuffer =\n+                                    ByteBuffer.wrap(data, 0, data.length).asDoubleBuffer();\n+                            for (int k = 0; k < rowLen; k++) {\n+                                value = dBuffer.get();\n+                                out.writeBytes(value + \" \");\n+                                // if (k < 10) {\n+                                // LOG.info(\"resultArray: \" + vectorArray[startPos + k]);\n+                                // }\n+                            }\n+                            out.writeBytes(\"\\n\");\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_FLOAT_DENSE\": {\n-            byte[] data = new byte[4 * (endCol - startCol)];\n-            rowLen = endCol - startCol;\n-            float value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              FloatBuffer fBuffer = ByteBuffer.wrap(data, 0, data.length).asFloatBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = fBuffer.get();\n-                out.writeBytes(value + \" \");\n-              }\n-              out.writeBytes(\"\\n\");\n-            }\n-            break;\n-          }\n+                    case \"T_FLOAT_DENSE\": {\n+                        byte[] data = new byte[4 * (endCol - startCol)];\n+                        rowLen = endCol - startCol;\n+                        float value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                            \"\\n\");\n+                            fin.read(data, 0, data.length);\n+                            FloatBuffer fBuffer =\n+                                    ByteBuffer.wrap(data, 0, data.length).asFloatBuffer();\n+                            for (int k = 0; k < rowLen; k++) {\n+                                value = fBuffer.get();\n+                                out.writeBytes(value + \" \");\n+                            }\n+                            out.writeBytes(\"\\n\");\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_INT_SPARSE\": {\n-            int key;\n-            int value;\n-            for (int j = 0; j < rowNum; j++) {\n-              rowIndex = fin.readInt();\n-              clock = fin.readInt();\n-              rowLen = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n-              for (int k = 0; k < rowLen; k++) {\n-                key = fin.readInt();\n-                value = fin.readInt();\n-                out.writeBytes(key + \":\" + value + \" \");\n-              }\n-            }\n-            break;\n-          }\n+                    case \"T_INT_SPARSE\": {\n+                        int key;\n+                        int value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            rowIndex = fin.readInt();\n+                            clock = fin.readInt();\n+                            rowLen = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen +\n+                                            \"\\n\");\n+                            for (int k = 0; k < rowLen; k++) {\n+                                key = fin.readInt();\n+                                value = fin.readInt();\n+                                out.writeBytes(key + \":\" + value + \" \");\n+                            }\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_INT_DENSE\": {\n-            byte[] data = new byte[4 * (endCol - startCol)];\n-            rowLen = endCol - startCol;\n-            int value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length)\n-                      .order(ByteOrder.nativeOrder()).asIntBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = iBuffer.get();\n-                out.writeBytes(value + \" \");\n-              }\n-              // for (int k = 0; k < rowLen; k++) {\n-              // LOG.info(\"Array[\" + String.valueOf(k) + \": \" + String.valueOf(vectorArray));\n-              // }\n-            }\n-            break;\n-          }\n+                    case \"T_INT_DENSE\": {\n+                        byte[] data = new byte[4 * (endCol - startCol)];\n+                        rowLen = endCol - startCol;\n+                        int value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                            \"\\n\");\n+                            fin.read(data, 0, data.length);\n+                            IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length)\n+                                    .order(ByteOrder.nativeOrder()).asIntBuffer();\n+                            for (int k = 0; k < rowLen; k++) {\n+                                value = iBuffer.get();\n+                                out.writeBytes(value + \" \");\n+                            }\n+                            // for (int k = 0; k < rowLen; k++) {\n+                            // LOG.info(\"Array[\" + String.valueOf(k) + \": \" + String.valueOf(vectorArray));\n+                            // }\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_INT_ARBITRARY\": {\n-            byte[] data = new byte[4 * (endCol - startCol)];\n-            String denseOrSparse;\n-            int nnz;\n-            int key;\n-            int value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              denseOrSparse = fin.readUTF();\n-              if (denseOrSparse.equals(\"T_INT_DENSE\")) {\n-                rowLen = endCol - startCol;\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \" type:\"\n-                        + denseOrSparse + \"\\n\");\n-                fin.read(data, 0, data.length);\n-                IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length).asIntBuffer();\n-                for (int k = 0; k < rowLen; k++) {\n-                  value = iBuffer.get();\n-                  out.writeBytes(value + \" \");\n-                }\n-              } else if (denseOrSparse.equals(\"T_INT_SPARSE\")) {\n-                nnz = fin.readInt();\n-                rowLen = fin.readInt();\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen\n-                        + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n-                for (int k = 0; k < rowLen; k++) {\n-                  key = fin.readInt();\n-                  value = fin.readInt();\n-                  out.writeBytes(key + \":\" + value + \" \");\n+                    case \"T_INT_ARBITRARY\": {\n+                        byte[] data = new byte[4 * (endCol - startCol)];\n+                        String denseOrSparse;\n+                        int nnz;\n+                        int key;\n+                        int value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            denseOrSparse = fin.readUTF();\n+                            if (denseOrSparse.equals(\"T_INT_DENSE\")) {\n+                                rowLen = endCol - startCol;\n+                                out.writeBytes(\n+                                        \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                                \" type:\"\n+                                                + denseOrSparse + \"\\n\");\n+                                fin.read(data, 0, data.length);\n+                                IntBuffer iBuffer =\n+                                        ByteBuffer.wrap(data, 0, data.length).asIntBuffer();\n+                                for (int k = 0; k < rowLen; k++) {\n+                                    value = iBuffer.get();\n+                                    out.writeBytes(value + \" \");\n+                                }\n+                            } else if (denseOrSparse.equals(\"T_INT_SPARSE\")) {\n+                                nnz = fin.readInt();\n+                                rowLen = fin.readInt();\n+                                out.writeBytes(\n+                                        \"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen\n+                                                + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n+                                for (int k = 0; k < rowLen; k++) {\n+                                    key = fin.readInt();\n+                                    value = fin.readInt();\n+                                    out.writeBytes(key + \":\" + value + \" \");\n+                                }\n+                            } else {\n+                                LOG.error(denseOrSparse + \" type error,need T_INT_ARBITRARY\");\n+                            }\n+                        }\n+                        break;\n+                    }\n                 }\n-              } else {\n-                LOG.error(denseOrSparse+\" type error,need T_INT_ARBITRARY\");\n-              }\n+\n+                fin.close();\n+                out.close();\n+                isSuccess.set(true);\n+                finishFlag.set(true);\n+            } catch (IOException e) {\n+                errorLog = \"convert partFile \" + status.toString() + \" error\";\n+                LOG.error(errorLog, e);\n+                isSuccess.set(false);\n+            } finally {\n+                LOG.info(\"convert partFile \" + status.toString() + \" cost time: \"\n+                        + (Time.monotonicNow() - startTime) + \"ms!\");\n+                finishFlag.set(true);\n             }\n-            break;\n-          }\n         }\n \n-        fin.close();\n-        out.close();\n-        isSuccess.set(true);\n-        finishFlag.set(true);\n-      } catch (IOException e) {\n-        errorLog = \"convert partFile \" + status.toString() + \" error\";\n-        LOG.error(errorLog, e);\n-        isSuccess.set(false);\n-      } finally {\n-        LOG.info(\"convert partFile \" + status.toString() + \" cost time: \"\n-                + (Time.monotonicNow() - startTime) + \"ms!\");\n-        finishFlag.set(true);\n-      }\n-    }\n+        /**\n+         * Is success.\n+         *\n+         * @return true if success, else false\n+         */\n+        public boolean isSuccess() {\n+            return isSuccess.get();\n+        }\n \n-    /**\n-     * Is success.\n-     *\n-     * @return true if success, else false\n-     */\n-    public boolean isSuccess() {\n-      return isSuccess.get();\n+        /**\n+         * Gets error log\n+         *\n+         * @return the error log if exists\n+         */\n+        public String getErrorLog() {\n+            return errorLog;\n+        }\n     }\n \n-    /**\n-     * Gets error log\n-     *\n-     * @return the error log if exists\n-     */\n-    public String getErrorLog() {\n-      return errorLog;\n-    }\n-  }\n+    public void convertInit() throws IOException {\n+        fileStatus = null;\n+        LOG.info(\"read model from \" + inputStr);\n+        if (inputStr == null) {\n+            throw new IOException(\"inputStr is null\");\n+        }\n+        Path inputPath = new Path(inputStr);\n+        Configuration conf = new Configuration();\n+        infs = inputPath.getFileSystem(conf);\n+        fileStatus = infs.listStatus(inputPath);\n \n-  public void convertInit() throws IOException {\n-    fileStatus = null;\n-    LOG.info(\"read model from \" + inputStr);\n-    if (inputStr == null) {\n-      throw new IOException(\"inputStr is null\");\n-    }\n-    Path inputPath = new Path(inputStr);\n-    Configuration conf = new Configuration();\n-    infs = inputPath.getFileSystem(conf);\n-    fileStatus = infs.listStatus(inputPath);\n+        if (outputStr == null) {\n+            throw new IOException(\"outputStr is null\");\n+        }\n \n-    if (outputStr == null) {\n-      throw new IOException(\"outputStr is null\");\n+        outputPath = new Path(new Path(outputStr, \"model\"), modelName);\n+        LOG.info(\"outputPath:\" + outputPath.toString());\n+        infs.mkdirs(outputPath);\n     }\n \n-    outputPath = new Path(new Path(outputStr, \"model\"), modelName);\n-    LOG.info(\"outputPath:\" + outputPath.toString());\n-    infs.mkdirs(outputPath);\n-  }\n-\n-  public void convertModel() throws IOException, InterruptedException {\n-    if (isConverting.get() == true) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"model is converting......\");\n-      }\n-      return;\n-    }\n-    LOG.info(\"to start convert tasks!\");\n-    isConverting.set(true);\n-    long startTime = Time.monotonicNow();\n+    public void convertModel() throws IOException, InterruptedException {\n+        if (isConverting.get() == true) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"model is converting......\");\n+            }\n+            return;\n+        }\n+        LOG.info(\"to start convert tasks!\");\n+        isConverting.set(true);\n+        long startTime = Time.monotonicNow();\n \n-    convertInit();\n-    ThreadFactory convertThreadFacotry =\n-            new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n-    convertTaskPool = Executors.newFixedThreadPool(convertThreadCount, convertThreadFacotry);\n-    List<ConvertTask> allConvertTasks = new ArrayList<>();\n-    Configuration conf;\n-    FileSystem outfs;\n-    for (int i = 0; i < fileStatus.length; i++) {\n-      FileStatus status = fileStatus[i];\n-      conf = new Configuration();\n-      outfs = outputPath.getFileSystem(conf);\n-      FSDataOutputStream out = outfs.create(new Path(outputPath, modelName + i));\n-      ConvertTask ConvertTask = new ConvertTask(status, out);\n-      allConvertTasks.add(ConvertTask);\n-      convertTaskPool.execute(ConvertTask);\n-    }\n-    boolean convertSuccess = true;\n-    String errorLog = null;\n-    for (ConvertTask task : allConvertTasks) {\n-      while (task.finishFlag.get() != true) {\n-        try {\n-          Thread.sleep(1000);\n-        } catch (InterruptedException e) {\n-          e.printStackTrace();\n+        convertInit();\n+        ThreadFactory convertThreadFacotry =\n+                new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n+        convertTaskPool = Executors.newFixedThreadPool(convertThreadCount, convertThreadFacotry);\n+        List<ConvertTask> allConvertTasks = new ArrayList<>();\n+        Configuration conf;\n+        FileSystem outfs;\n+        for (int i = 0; i < fileStatus.length; i++) {\n+            FileStatus status = fileStatus[i];\n+            conf = new Configuration();\n+            outfs = outputPath.getFileSystem(conf);\n+            FSDataOutputStream out = outfs.create(new Path(outputPath, modelName + i));\n+            ConvertTask ConvertTask = new ConvertTask(status, out);\n+            allConvertTasks.add(ConvertTask);\n+            convertTaskPool.execute(ConvertTask);\n+        }\n+        boolean convertSuccess = true;\n+        String errorLog = null;\n+        for (ConvertTask task : allConvertTasks) {\n+            while (task.finishFlag.get() != true) {\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                continue;\n+            }\n+            if (task.isSuccess() == false) {\n+                convertSuccess = false;\n+                errorLog = task.getErrorLog();\n+            }\n+        }\n+        LOG.info(\"model convert cost time: \" + (Time.monotonicNow() - startTime) + \"ms\");\n+        convertTaskPool.shutdownNow();\n+        if (!convertSuccess) {\n+            LOG.error(\"convert failed for \" + errorLog);\n         }\n-        continue;\n-      }\n-      if (task.isSuccess() == false) {\n-        convertSuccess = false;\n-        errorLog = task.getErrorLog();\n-      }\n-    }\n-    LOG.info(\"model convert cost time: \" + (Time.monotonicNow() - startTime) + \"ms\");\n-    convertTaskPool.shutdownNow();\n-    if (!convertSuccess) {\n-      LOG.error(\"convert failed for \" + errorLog);\n     }\n-  }\n \n }\n",
            "diff_size": 326
        },
        {
            "tool": "naturalize",
            "violations": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "violations": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "90",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "191",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "215",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "225",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 149).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "247",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "304",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/1075/ModelParse.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/1075/ModelParse.java\nindex 56d79ac3856..f57d916c73c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/1075/ModelParse.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/1075/ModelParse.java\n@@ -32,6 +32,7 @@ import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n public class ModelParse {\n+\n   private static final Log LOG = LogFactory.getLog(ModelParse.class);\n   private ExecutorService convertTaskPool;\n   private static FileSystem infs;\n@@ -45,7 +46,6 @@ public class ModelParse {\n   private int convertThreadCount;\n   private Boolean type;// true-dense;false-sparse;\n \n-\n   public ModelParse(String inputStr, String outputStr, String modelName, int convertThreadCount) {\n     this.inputStr = inputStr;\n     this.outputStr = outputStr;\n@@ -73,33 +73,36 @@ public class ModelParse {\n       try {\n         FSDataInputStream fin;\n         fin = infs.open(status.getPath());\n+\n         int matrixId = fin.readInt();\n         out.writeBytes(\"matrixId:\" + matrixId + \"\\n\");\n+\n         int partSize = fin.readInt();\n         out.writeBytes(\"partSize:\" + partSize + \"\\n\");\n \n         // read partition header\n+\n         int startRow = fin.readInt();\n         int startCol = fin.readInt();\n         int endRow = fin.readInt();\n         int endCol = fin.readInt();\n         String rowType = fin.readUTF();\n-        String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \"\n-                + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n+        String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \" + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n         out.writeBytes(patInfo + \"\\n\");\n         LOG.info(patInfo);\n \n         int rowNum = fin.readInt();\n         LOG.info(\"rowNum=\" + rowNum);\n         out.writeBytes(\"rowNum:\" + rowNum + \"\\n\");\n+\n         int rowIndex;\n         int rowLen;\n         int startPos;\n         int clock;\n-\n         switch (rowType) {\n           case \"T_DOUBLE_SPARSE\": {\n             type = false;\n+\n             int key;\n             double value;\n             for (int j = 0; j < rowNum; j++) {\n@@ -178,14 +181,14 @@ public class ModelParse {\n           case \"T_INT_DENSE\": {\n             byte[] data = new byte[4 * (endCol - startCol)];\n             rowLen = endCol - startCol;\n+\n             int value;\n             for (int j = 0; j < rowNum; j++) {\n               clock = fin.readInt();\n               rowIndex = fin.readInt();\n               out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n               fin.read(data, 0, data.length);\n-              IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length)\n-                      .order(ByteOrder.nativeOrder()).asIntBuffer();\n+              IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length).order(ByteOrder.nativeOrder()).asIntBuffer();\n               for (int k = 0; k < rowLen; k++) {\n                 value = iBuffer.get();\n                 out.writeBytes(value + \" \");\n@@ -209,8 +212,7 @@ public class ModelParse {\n               denseOrSparse = fin.readUTF();\n               if (denseOrSparse.equals(\"T_INT_DENSE\")) {\n                 rowLen = endCol - startCol;\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \" type:\"\n-                        + denseOrSparse + \"\\n\");\n+                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \" type:\" + denseOrSparse + \"\\n\");\n                 fin.read(data, 0, data.length);\n                 IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length).asIntBuffer();\n                 for (int k = 0; k < rowLen; k++) {\n@@ -218,23 +220,21 @@ public class ModelParse {\n                   out.writeBytes(value + \" \");\n                 }\n               } else if (denseOrSparse.equals(\"T_INT_SPARSE\")) {\n-                nnz = fin.readInt();\n-                rowLen = fin.readInt();\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen\n-                        + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n-                for (int k = 0; k < rowLen; k++) {\n-                  key = fin.readInt();\n-                  value = fin.readInt();\n-                  out.writeBytes(key + \":\" + value + \" \");\n-                }\n+                       nnz = fin.readInt();\n+                       rowLen = fin.readInt();\n+                       out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n+                       for (int k = 0; k < rowLen; k++) {\n+                         key = fin.readInt();\n+                         value = fin.readInt();\n+                         out.writeBytes(key + \":\" + value + \" \");\n+                       }\n               } else {\n-                LOG.error(denseOrSparse+\" type error,need T_INT_ARBITRARY\");\n+                       LOG.error(denseOrSparse + \" type error,need T_INT_ARBITRARY\");\n               }\n             }\n             break;\n           }\n         }\n-\n         fin.close();\n         out.close();\n         isSuccess.set(true);\n@@ -244,8 +244,7 @@ public class ModelParse {\n         LOG.error(errorLog, e);\n         isSuccess.set(false);\n       } finally {\n-        LOG.info(\"convert partFile \" + status.toString() + \" cost time: \"\n-                + (Time.monotonicNow() - startTime) + \"ms!\");\n+        LOG.info(\"convert partFile \" + status.toString() + \" cost time: \" + (Time.monotonicNow() - startTime) + \"ms!\");\n         finishFlag.set(true);\n       }\n     }\n@@ -255,6 +254,7 @@ public class ModelParse {\n      *\n      * @return true if success, else false\n      */\n+\n     public boolean isSuccess() {\n       return isSuccess.get();\n     }\n@@ -264,6 +264,7 @@ public class ModelParse {\n      *\n      * @return the error log if exists\n      */\n+\n     public String getErrorLog() {\n       return errorLog;\n     }\n@@ -275,15 +276,14 @@ public class ModelParse {\n     if (inputStr == null) {\n       throw new IOException(\"inputStr is null\");\n     }\n+\n     Path inputPath = new Path(inputStr);\n     Configuration conf = new Configuration();\n     infs = inputPath.getFileSystem(conf);\n     fileStatus = infs.listStatus(inputPath);\n-\n     if (outputStr == null) {\n       throw new IOException(\"outputStr is null\");\n     }\n-\n     outputPath = new Path(new Path(outputStr, \"model\"), modelName);\n     LOG.info(\"outputPath:\" + outputPath.toString());\n     infs.mkdirs(outputPath);\n@@ -298,11 +298,10 @@ public class ModelParse {\n     }\n     LOG.info(\"to start convert tasks!\");\n     isConverting.set(true);\n-    long startTime = Time.monotonicNow();\n \n+    long startTime = Time.monotonicNow();\n     convertInit();\n-    ThreadFactory convertThreadFacotry =\n-            new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n+    ThreadFactory convertThreadFacotry = new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n     convertTaskPool = Executors.newFixedThreadPool(convertThreadCount, convertThreadFacotry);\n     List<ConvertTask> allConvertTasks = new ArrayList<>();\n     Configuration conf;\n@@ -316,6 +315,7 @@ public class ModelParse {\n       allConvertTasks.add(ConvertTask);\n       convertTaskPool.execute(ConvertTask);\n     }\n+\n     boolean convertSuccess = true;\n     String errorLog = null;\n     for (ConvertTask task : allConvertTasks) {\n@@ -327,6 +327,7 @@ public class ModelParse {\n         }\n         continue;\n       }\n+\n       if (task.isSuccess() == false) {\n         convertSuccess = false;\n         errorLog = task.getErrorLog();\n@@ -339,4 +340,4 @@ public class ModelParse {\n     }\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 40
        },
        {
            "tool": "styler_random",
            "violations": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "violations": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "checkstyle_idea",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}