{
    "project_name": "Angel-ML-angel",
    "violation_id": "245",
    "information": {
        "violations": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "checkstyle_idea",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/245/NodeUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/245/NodeUtils.java\nindex 02877cdb449..f5fdbd0303f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/245/NodeUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/245/NodeUtils.java\n@@ -14,6 +14,7 @@\n  * the License.\n  *\n  */\n+\n package com.tencent.angel.graph.data;\n \n import com.tencent.angel.ml.math2.VFactory;\n@@ -27,244 +28,244 @@ import java.io.DataOutputStream;\n import java.io.IOException;\n \n public class NodeUtils {\n-  public static int dataLen(IntFloatVector feats) {\n-    return 12 + 4 * (int)feats.getSize();\n-  }\n-\n-  public static void serialize(IntFloatVector feats, ByteBuf output) {\n-    output.writeInt(feats.getDim());\n-    output.writeInt((int) feats.getSize());\n-    if (feats.isDense()) {\n-      output.writeInt(StorageMethod.DENSE.getValue());\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < values.length; i++) {\n-        output.writeFloat(values[i]);\n-      }\n-    } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n-    } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n+    public static int dataLen(IntFloatVector feats) {\n+        return 12 + 4 * (int) feats.getSize();\n     }\n-  }\n \n-  public static IntFloatVector deserialize(ByteBuf input) {\n-    IntFloatVector feats;\n-    int dim = input.readInt();\n-    int len = input.readInt();\n-    StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n-    switch (storageMethod) {\n-      case DENSE: {\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n-          values[i] = input.readFloat();\n+    public static void serialize(IntFloatVector feats, ByteBuf output) {\n+        output.writeInt(feats.getDim());\n+        output.writeInt((int) feats.getSize());\n+        if (feats.isDense()) {\n+            output.writeInt(StorageMethod.DENSE.getValue());\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < values.length; i++) {\n+                output.writeFloat(values[i]);\n+            }\n+        } else if (feats.isSparse()) {\n+            output.writeInt(StorageMethod.SPARSE.getValue());\n+            ObjectIterator<Entry> iter = feats\n+                    .getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Entry entry = iter.next();\n+                output.writeInt(entry.getIntKey());\n+                output.writeFloat(entry.getFloatValue());\n+            }\n+        } else if (feats.isSorted()) {\n+            output.writeInt(StorageMethod.SORTED.getValue());\n+            int[] keys = feats.getStorage().getIndices();\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < keys.length; i++) {\n+                output.writeInt(keys[i]);\n+                output.writeFloat(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupport storage type \");\n         }\n-        feats = VFactory.denseFloatVector(values);\n-        break;\n-      }\n+    }\n \n-      case SPARSE: {\n-        feats = VFactory.sparseFloatVector(dim, len);\n-        for(int i = 0; i < len; i++) {\n-          feats.set(input.readInt(), input.readFloat());\n-        }\n-        break;\n-      }\n+    public static IntFloatVector deserialize(ByteBuf input) {\n+        IntFloatVector feats;\n+        int dim = input.readInt();\n+        int len = input.readInt();\n+        StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n+        switch (storageMethod) {\n+            case DENSE: {\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.denseFloatVector(values);\n+                break;\n+            }\n \n-      case SORTED:{\n-        int [] keys = new int[len];\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n-          keys[i] = input.readInt();\n-          values[i] = input.readFloat();\n-        }\n-        feats = VFactory.sortedFloatVector(dim, keys, values);\n-        break;\n-      }\n+            case SPARSE: {\n+                feats = VFactory.sparseFloatVector(dim, len);\n+                for (int i = 0; i < len; i++) {\n+                    feats.set(input.readInt(), input.readFloat());\n+                }\n+                break;\n+            }\n \n-      default:\n-        throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n-    }\n+            case SORTED: {\n+                int[] keys = new int[len];\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    keys[i] = input.readInt();\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.sortedFloatVector(dim, keys, values);\n+                break;\n+            }\n \n-    return feats;\n-  }\n+            default:\n+                throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n+        }\n \n-  public static void serialize(IntFloatVector feats, DataOutputStream output) throws IOException {\n-    output.writeInt(feats.getDim());\n-    output.writeInt((int) feats.getSize());\n-    if (feats.isDense()) {\n-      output.writeInt(StorageMethod.DENSE.getValue());\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < values.length; i++) {\n-        output.writeFloat(values[i]);\n-      }\n-    } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n-    } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n+        return feats;\n     }\n-  }\n \n-  public static IntFloatVector deserialize(DataInputStream input) throws IOException {\n-    IntFloatVector feats;\n-    int dim = input.readInt();\n-    int len = input.readInt();\n-    StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n-    switch (storageMethod) {\n-      case DENSE: {\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n-          values[i] = input.readFloat();\n+    public static void serialize(IntFloatVector feats, DataOutputStream output) throws IOException {\n+        output.writeInt(feats.getDim());\n+        output.writeInt((int) feats.getSize());\n+        if (feats.isDense()) {\n+            output.writeInt(StorageMethod.DENSE.getValue());\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < values.length; i++) {\n+                output.writeFloat(values[i]);\n+            }\n+        } else if (feats.isSparse()) {\n+            output.writeInt(StorageMethod.SPARSE.getValue());\n+            ObjectIterator<Entry> iter = feats\n+                    .getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Entry entry = iter.next();\n+                output.writeInt(entry.getIntKey());\n+                output.writeFloat(entry.getFloatValue());\n+            }\n+        } else if (feats.isSorted()) {\n+            output.writeInt(StorageMethod.SORTED.getValue());\n+            int[] keys = feats.getStorage().getIndices();\n+            float[] values = feats.getStorage().getValues();\n+            for (int i = 0; i < keys.length; i++) {\n+                output.writeInt(keys[i]);\n+                output.writeFloat(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupport storage type \");\n         }\n-        feats = VFactory.denseFloatVector(values);\n-        break;\n-      }\n+    }\n \n-      case SPARSE: {\n-        feats = VFactory.sparseFloatVector(dim, len);\n-        for(int i = 0; i < len; i++) {\n-          feats.set(input.readInt(), input.readFloat());\n-        }\n-        break;\n-      }\n+    public static IntFloatVector deserialize(DataInputStream input) throws IOException {\n+        IntFloatVector feats;\n+        int dim = input.readInt();\n+        int len = input.readInt();\n+        StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n+        switch (storageMethod) {\n+            case DENSE: {\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.denseFloatVector(values);\n+                break;\n+            }\n \n-      case SORTED:{\n-        int [] keys = new int[len];\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n-          keys[i] = input.readInt();\n-          values[i] = input.readFloat();\n-        }\n-        feats = VFactory.sortedFloatVector(dim, keys, values);\n-        break;\n-      }\n+            case SPARSE: {\n+                feats = VFactory.sparseFloatVector(dim, len);\n+                for (int i = 0; i < len; i++) {\n+                    feats.set(input.readInt(), input.readFloat());\n+                }\n+                break;\n+            }\n \n-      default:\n-        throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n-    }\n+            case SORTED: {\n+                int[] keys = new int[len];\n+                float[] values = new float[len];\n+                for (int i = 0; i < len; i++) {\n+                    keys[i] = input.readInt();\n+                    values[i] = input.readFloat();\n+                }\n+                feats = VFactory.sortedFloatVector(dim, keys, values);\n+                break;\n+            }\n \n-    return feats;\n-  }\n+            default:\n+                throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n+        }\n \n-  public static void serialize(float [] feats, ByteBuf output) {\n-    if(feats != null) {\n-      output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n-        output.writeFloat(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+        return feats;\n     }\n-  }\n-  public static void serialize(double [] feats, ByteBuf output) throws IOException {\n-    if(feats != null) {\n-      output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n-        output.writeDouble(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+\n+    public static void serialize(float[] feats, ByteBuf output) {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeFloat(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n     }\n-  }\n \n+    public static void serialize(double[] feats, ByteBuf output) throws IOException {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeDouble(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n+    }\n \n \n-  public static void serialize(float [] feats, DataOutputStream output) throws IOException {\n-    if(feats != null) {\n-      output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n-        output.writeFloat(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+    public static void serialize(float[] feats, DataOutputStream output) throws IOException {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeFloat(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n     }\n-  }\n \n-  public static void serialize(double [] feats, DataOutputStream output) throws IOException {\n-    if(feats != null) {\n-      output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n-        output.writeDouble(feats[i]);\n-      }\n-    } else {\n-      output.writeInt(0);\n+    public static void serialize(double[] feats, DataOutputStream output) throws IOException {\n+        if (feats != null) {\n+            output.writeInt(feats.length);\n+            for (int i = 0; i < feats.length; i++) {\n+                output.writeDouble(feats[i]);\n+            }\n+        } else {\n+            output.writeInt(0);\n+        }\n     }\n-  }\n \n \n-  public static float[] deserializeFloats(DataInputStream input) throws IOException {\n-    int len = input.readInt();\n-    if(len > 0) {\n-      float[] res = new float[len];\n-      for(int i = 0; i < len; i++) {\n-        res[i] = input.readInt();\n-      }\n-      return res;\n-    } else {\n-      return null;\n+    public static float[] deserializeFloats(DataInputStream input) throws IOException {\n+        int len = input.readInt();\n+        if (len > 0) {\n+            float[] res = new float[len];\n+            for (int i = 0; i < len; i++) {\n+                res[i] = input.readInt();\n+            }\n+            return res;\n+        } else {\n+            return null;\n+        }\n     }\n-  }\n \n-  public static float[] deserializeFloats(ByteBuf input) {\n-    int len = input.readInt();\n-    if(len > 0) {\n-      float[] res = new float[len];\n-      for(int i = 0; i < len; i++) {\n-        res[i] = input.readFloat();\n-      }\n-      return res;\n-    } else {\n-      return null;\n+    public static float[] deserializeFloats(ByteBuf input) {\n+        int len = input.readInt();\n+        if (len > 0) {\n+            float[] res = new float[len];\n+            for (int i = 0; i < len; i++) {\n+                res[i] = input.readFloat();\n+            }\n+            return res;\n+        } else {\n+            return null;\n+        }\n     }\n-  }\n \n-  public static double[] deserializeDoubles(ByteBuf input) {\n-    int len = input.readInt();\n-    if(len > 0) {\n-      double[] res = new double[len];\n-      for(int i = 0; i < len; i++) {\n-        res[i] = input.readDouble();\n-      }\n-      return res;\n-    } else {\n-      return null;\n+    public static double[] deserializeDoubles(ByteBuf input) {\n+        int len = input.readInt();\n+        if (len > 0) {\n+            double[] res = new double[len];\n+            for (int i = 0; i < len; i++) {\n+                res[i] = input.readDouble();\n+            }\n+            return res;\n+        } else {\n+            return null;\n+        }\n     }\n-  }\n \n-  public static int dataLen(float[] feats) {\n-    return 4 + (feats == null ? 0 : feats.length * 4);\n-  }\n+    public static int dataLen(float[] feats) {\n+        return 4 + (feats == null ? 0 : feats.length * 4);\n+    }\n \n-  public static int dataLen(double[] feats) {\n-    return 4 + (feats == null ? 0 : feats.length * 8);\n-  }\n+    public static int dataLen(double[] feats) {\n+        return 4 + (feats == null ? 0 : feats.length * 8);\n+    }\n }\n",
            "diff_size": 290
        },
        {
            "tool": "naturalize",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/245/NodeUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/245/NodeUtils.java\nindex 02877cdb449..85261d4f25a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/245/NodeUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/245/NodeUtils.java\n@@ -42,9 +42,8 @@ public class NodeUtils {\n       }\n     } else if (feats.isSparse()) {\n       output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n+      ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+while (iter.hasNext()) {\n         Entry entry = iter.next();\n         output.writeInt(entry.getIntKey());\n         output.writeFloat(entry.getFloatValue());\n@@ -69,8 +68,8 @@ public class NodeUtils {\n     StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n     switch (storageMethod) {\n       case DENSE: {\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           values[i] = input.readFloat();\n         }\n         feats = VFactory.denseFloatVector(values);\n@@ -79,16 +78,16 @@ public class NodeUtils {\n \n       case SPARSE: {\n         feats = VFactory.sparseFloatVector(dim, len);\n-        for(int i = 0; i < len; i++) {\n+        for (int i = 0; i < len; i++) {\n           feats.set(input.readInt(), input.readFloat());\n         }\n         break;\n       }\n \n-      case SORTED:{\n-        int [] keys = new int[len];\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+      case SORTED: {\n+        int[] keys = new int[len];\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           keys[i] = input.readInt();\n           values[i] = input.readFloat();\n         }\n@@ -98,7 +97,7 @@ public class NodeUtils {\n \n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n-    }\n+  }\n \n     return feats;\n   }\n@@ -114,9 +113,8 @@ public class NodeUtils {\n       }\n     } else if (feats.isSparse()) {\n       output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n+      ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+while (iter.hasNext()) {\n         Entry entry = iter.next();\n         output.writeInt(entry.getIntKey());\n         output.writeFloat(entry.getFloatValue());\n@@ -141,8 +139,8 @@ public class NodeUtils {\n     StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n     switch (storageMethod) {\n       case DENSE: {\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           values[i] = input.readFloat();\n         }\n         feats = VFactory.denseFloatVector(values);\n@@ -151,16 +149,16 @@ public class NodeUtils {\n \n       case SPARSE: {\n         feats = VFactory.sparseFloatVector(dim, len);\n-        for(int i = 0; i < len; i++) {\n+        for (int i = 0; i < len; i++) {\n           feats.set(input.readInt(), input.readFloat());\n         }\n         break;\n       }\n \n-      case SORTED:{\n-        int [] keys = new int[len];\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+      case SORTED: {\n+        int[] keys = new int[len];\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           keys[i] = input.readInt();\n           values[i] = input.readFloat();\n         }\n@@ -170,25 +168,26 @@ public class NodeUtils {\n \n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n-    }\n+  }\n \n     return feats;\n   }\n \n-  public static void serialize(float [] feats, ByteBuf output) {\n+  public static void serialize(float[] feats, ByteBuf output) {\n     if(feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeFloat(feats[i]);\n       }\n     } else {\n       output.writeInt(0);\n     }\n   }\n-  public static void serialize(double [] feats, ByteBuf output) throws IOException {\n+\n+public static void serialize(double [] feats, ByteBuf output) throws IOException {\n     if(feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeDouble(feats[i]);\n       }\n     } else {\n@@ -196,12 +195,10 @@ public class NodeUtils {\n     }\n   }\n \n-\n-\n-  public static void serialize(float [] feats, DataOutputStream output) throws IOException {\n+public static void serialize(float[] feats, DataOutputStream output) throws IOException {\n     if(feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeFloat(feats[i]);\n       }\n     } else {\n@@ -212,7 +209,7 @@ public class NodeUtils {\n   public static void serialize(double [] feats, DataOutputStream output) throws IOException {\n     if(feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeDouble(feats[i]);\n       }\n     } else {\n@@ -223,9 +220,9 @@ public class NodeUtils {\n \n   public static float[] deserializeFloats(DataInputStream input) throws IOException {\n     int len = input.readInt();\n-    if(len > 0) {\n+    if (len > 0) {\n       float[] res = new float[len];\n-      for(int i = 0; i < len; i++) {\n+      for (int i = 0; i < len; i++) {\n         res[i] = input.readInt();\n       }\n       return res;\n@@ -236,9 +233,9 @@ public class NodeUtils {\n \n   public static float[] deserializeFloats(ByteBuf input) {\n     int len = input.readInt();\n-    if(len > 0) {\n+    if (len > 0) {\n       float[] res = new float[len];\n-      for(int i = 0; i < len; i++) {\n+      for (int i = 0; i < len; i++) {\n         res[i] = input.readFloat();\n       }\n       return res;\n@@ -249,9 +246,9 @@ public class NodeUtils {\n \n   public static double[] deserializeDoubles(ByteBuf input) {\n     int len = input.readInt();\n-    if(len > 0) {\n+    if (len > 0) {\n       double[] res = new double[len];\n-      for(int i = 0; i < len; i++) {\n+      for (int i = 0; i < len; i++) {\n         res[i] = input.readDouble();\n       }\n       return res;\n@@ -267,4 +264,4 @@ public class NodeUtils {\n   public static int dataLen(double[] feats) {\n     return 4 + (feats == null ? 0 : feats.length * 8);\n   }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 39
        },
        {
            "tool": "codebuff",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/245/NodeUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/245/NodeUtils.java\nindex 02877cdb449..4e3ed35d3a9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/245/NodeUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/245/NodeUtils.java\n@@ -27,8 +27,9 @@ import java.io.DataOutputStream;\n import java.io.IOException;\n \n public class NodeUtils {\n+\n   public static int dataLen(IntFloatVector feats) {\n-    return 12 + 4 * (int)feats.getSize();\n+    return 12 + 4 * (int) feats.getSize();\n   }\n \n   public static void serialize(IntFloatVector feats, ByteBuf output) {\n@@ -41,25 +42,25 @@ public class NodeUtils {\n         output.writeFloat(values[i]);\n       }\n     } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n+             output.writeInt(StorageMethod.SPARSE.getValue());\n+             ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Entry entry = iter.next();\n+               output.writeInt(entry.getIntKey());\n+               output.writeFloat(entry.getFloatValue());\n+             }\n     } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n-    }\n+             output.writeInt(StorageMethod.SORTED.getValue());\n+\n+             int[] keys = feats.getStorage().getIndices();\n+             float[] values = feats.getStorage().getValues();\n+             for (int i = 0; i < keys.length; i++) {\n+               output.writeInt(keys[i]);\n+               output.writeFloat(values[i]);\n+             }\n+           } else {\n+             throw new UnsupportedOperationException(\"Unsupport storage type \");\n+           }\n   }\n \n   public static IntFloatVector deserialize(ByteBuf input) {\n@@ -69,8 +70,8 @@ public class NodeUtils {\n     StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n     switch (storageMethod) {\n       case DENSE: {\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           values[i] = input.readFloat();\n         }\n         feats = VFactory.denseFloatVector(values);\n@@ -79,16 +80,16 @@ public class NodeUtils {\n \n       case SPARSE: {\n         feats = VFactory.sparseFloatVector(dim, len);\n-        for(int i = 0; i < len; i++) {\n+        for (int i = 0; i < len; i++) {\n           feats.set(input.readInt(), input.readFloat());\n         }\n         break;\n       }\n \n-      case SORTED:{\n-        int [] keys = new int[len];\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+      case SORTED: {\n+        int[] keys = new int[len];\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           keys[i] = input.readInt();\n           values[i] = input.readFloat();\n         }\n@@ -99,7 +100,6 @@ public class NodeUtils {\n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n     }\n-\n     return feats;\n   }\n \n@@ -113,25 +113,25 @@ public class NodeUtils {\n         output.writeFloat(values[i]);\n       }\n     } else if (feats.isSparse()) {\n-      output.writeInt(StorageMethod.SPARSE.getValue());\n-      ObjectIterator<Entry> iter = feats\n-          .getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Entry entry = iter.next();\n-        output.writeInt(entry.getIntKey());\n-        output.writeFloat(entry.getFloatValue());\n-      }\n+             output.writeInt(StorageMethod.SPARSE.getValue());\n+             ObjectIterator<Entry> iter = feats.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+               Entry entry = iter.next();\n+               output.writeInt(entry.getIntKey());\n+               output.writeFloat(entry.getFloatValue());\n+             }\n     } else if (feats.isSorted()) {\n-      output.writeInt(StorageMethod.SORTED.getValue());\n-      int[] keys = feats.getStorage().getIndices();\n-      float[] values = feats.getStorage().getValues();\n-      for (int i = 0; i < keys.length; i++) {\n-        output.writeInt(keys[i]);\n-        output.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\"Unsupport storage type \");\n-    }\n+             output.writeInt(StorageMethod.SORTED.getValue());\n+\n+             int[] keys = feats.getStorage().getIndices();\n+             float[] values = feats.getStorage().getValues();\n+             for (int i = 0; i < keys.length; i++) {\n+               output.writeInt(keys[i]);\n+               output.writeFloat(values[i]);\n+             }\n+           } else {\n+             throw new UnsupportedOperationException(\"Unsupport storage type \");\n+           }\n   }\n \n   public static IntFloatVector deserialize(DataInputStream input) throws IOException {\n@@ -141,8 +141,8 @@ public class NodeUtils {\n     StorageMethod storageMethod = StorageMethod.valuesOf(input.readInt());\n     switch (storageMethod) {\n       case DENSE: {\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           values[i] = input.readFloat();\n         }\n         feats = VFactory.denseFloatVector(values);\n@@ -151,16 +151,16 @@ public class NodeUtils {\n \n       case SPARSE: {\n         feats = VFactory.sparseFloatVector(dim, len);\n-        for(int i = 0; i < len; i++) {\n+        for (int i = 0; i < len; i++) {\n           feats.set(input.readInt(), input.readFloat());\n         }\n         break;\n       }\n \n-      case SORTED:{\n-        int [] keys = new int[len];\n-        float [] values = new float[len];\n-        for(int i = 0; i < len; i++) {\n+      case SORTED: {\n+        int[] keys = new int[len];\n+        float[] values = new float[len];\n+        for (int i = 0; i < len; i++) {\n           keys[i] = input.readInt();\n           values[i] = input.readFloat();\n         }\n@@ -171,24 +171,24 @@ public class NodeUtils {\n       default:\n         throw new UnsupportedOperationException(\"Unsupport storage type \" + storageMethod);\n     }\n-\n     return feats;\n   }\n \n-  public static void serialize(float [] feats, ByteBuf output) {\n-    if(feats != null) {\n+  public static void serialize(float[] feats, ByteBuf output) {\n+    if (feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeFloat(feats[i]);\n       }\n     } else {\n       output.writeInt(0);\n     }\n   }\n-  public static void serialize(double [] feats, ByteBuf output) throws IOException {\n-    if(feats != null) {\n+\n+  public static void serialize(double[] feats, ByteBuf output) throws IOException {\n+    if (feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeDouble(feats[i]);\n       }\n     } else {\n@@ -196,12 +196,10 @@ public class NodeUtils {\n     }\n   }\n \n-\n-\n-  public static void serialize(float [] feats, DataOutputStream output) throws IOException {\n-    if(feats != null) {\n+  public static void serialize(float[] feats, DataOutputStream output) throws IOException {\n+    if (feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeFloat(feats[i]);\n       }\n     } else {\n@@ -209,10 +207,10 @@ public class NodeUtils {\n     }\n   }\n \n-  public static void serialize(double [] feats, DataOutputStream output) throws IOException {\n-    if(feats != null) {\n+  public static void serialize(double[] feats, DataOutputStream output) throws IOException {\n+    if (feats != null) {\n       output.writeInt(feats.length);\n-      for(int i = 0; i < feats.length; i++) {\n+      for (int i = 0; i < feats.length; i++) {\n         output.writeDouble(feats[i]);\n       }\n     } else {\n@@ -220,12 +218,11 @@ public class NodeUtils {\n     }\n   }\n \n-\n   public static float[] deserializeFloats(DataInputStream input) throws IOException {\n     int len = input.readInt();\n-    if(len > 0) {\n+    if (len > 0) {\n       float[] res = new float[len];\n-      for(int i = 0; i < len; i++) {\n+      for (int i = 0; i < len; i++) {\n         res[i] = input.readInt();\n       }\n       return res;\n@@ -236,9 +233,9 @@ public class NodeUtils {\n \n   public static float[] deserializeFloats(ByteBuf input) {\n     int len = input.readInt();\n-    if(len > 0) {\n+    if (len > 0) {\n       float[] res = new float[len];\n-      for(int i = 0; i < len; i++) {\n+      for (int i = 0; i < len; i++) {\n         res[i] = input.readFloat();\n       }\n       return res;\n@@ -249,9 +246,9 @@ public class NodeUtils {\n \n   public static double[] deserializeDoubles(ByteBuf input) {\n     int len = input.readInt();\n-    if(len > 0) {\n+    if (len > 0) {\n       double[] res = new double[len];\n-      for(int i = 0; i < len; i++) {\n+      for (int i = 0; i < len; i++) {\n         res[i] = input.readDouble();\n       }\n       return res;\n@@ -267,4 +264,5 @@ public class NodeUtils {\n   public static int dataLen(double[] feats) {\n     return 4 + (feats == null ? 0 : feats.length * 8);\n   }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 80
        },
        {
            "tool": "styler_random",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "checkstyle_idea",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}