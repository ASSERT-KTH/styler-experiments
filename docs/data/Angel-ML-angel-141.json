{
    "project_name": "Angel-ML-angel",
    "violation_id": "141",
    "information": {
        "violations": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "checkstyle_idea",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "58",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/141/GBDTParam.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/141/GBDTParam.java\nindex 9dd14bd185c..c7e66cd0106 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/141/GBDTParam.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/141/GBDTParam.java\n@@ -22,205 +22,208 @@ import com.tencent.angel.spark.ml.tree.util.Maths;\n \n public class GBDTParam extends RegTParam {\n \n-  public int numClass; // number of classes/labels\n-  public int numTree;  // number of trees\n-  public int numThread;  // parallelism\n-\n-  public boolean histSubtraction;\n-  public boolean lighterChildFirst;\n-  //public boolean leafwise;  // true if leaf-wise training, false if level-wise training\n-\n-  public boolean fullHessian;  // whether to use full hessian matrix instead of diagonal\n-  public float minChildWeight;  // minimum amount of hessian (weight) allowed for a child\n-  public int minNodeInstance;\n-  public float regAlpha;  // L1 regularization factor\n-  public float regLambda;  // L2 regularization factor\n-  public float maxLeafWeight; // maximum leaf weight, default 0 means no constraints\n-\n-  public String lossFunc; // name of loss function\n-  public String[] evalMetrics; // name of eval metric\n-\n-  /**\n-   * Whether the sum of hessian satisfies weight\n-   *\n-   * @param sumHess sum of hessian values\n-   * @return true if satisfied, false otherwise\n-   */\n-  public boolean satisfyWeight(double sumHess) {\n-    return sumHess >= minChildWeight;\n-  }\n-\n-  public boolean satisfyWeight(double sumGrad, double sumHess) {\n-    return sumGrad != 0.0f && satisfyWeight(sumHess);\n-  }\n-\n-  /**\n-   * Whether the sum of hessian satisfies weight Since hessian matrix is positive, we have det(hess)\n-   * <= a11*a22*...*akk, thus we approximate det(hess) with a11*a22*...*akk\n-   *\n-   * @param sumHess sum of hessian values\n-   * @return true if satisfied, false otherwise\n-   */\n-  public boolean satisfyWeight(double[] sumHess) {\n-    if (minChildWeight == 0.0f) {\n-      return true;\n+    public int numClass; // number of classes/labels\n+    public int numTree;  // number of trees\n+    public int numThread;  // parallelism\n+\n+    public boolean histSubtraction;\n+    public boolean lighterChildFirst;\n+    //public boolean leafwise;  // true if leaf-wise training, false if level-wise training\n+\n+    public boolean fullHessian;  // whether to use full hessian matrix instead of diagonal\n+    public float minChildWeight;  // minimum amount of hessian (weight) allowed for a child\n+    public int minNodeInstance;\n+    public float regAlpha;  // L1 regularization factor\n+    public float regLambda;  // L2 regularization factor\n+    public float maxLeafWeight; // maximum leaf weight, default 0 means no constraints\n+\n+    public String lossFunc; // name of loss function\n+    public String[] evalMetrics; // name of eval metric\n+\n+    /**\n+     * Whether the sum of hessian satisfies weight\n+     *\n+     * @param sumHess sum of hessian values\n+     * @return true if satisfied, false otherwise\n+     */\n+    public boolean satisfyWeight(double sumHess) {\n+        return sumHess >= minChildWeight;\n     }\n-    double w = 1.0;\n-    if (!fullHessian) {\n-      for (double h : sumHess) {\n-        w *= h;\n-      }\n-    } else {\n-      for (int k = 0; k < numClass; k++) {\n-        int index = Maths.indexOfLowerTriangularMatrix(k, k);\n-        w *= sumHess[index];\n-      }\n-    }\n-    return w >= minChildWeight;\n-  }\n-\n-  public boolean satisfyWeight(double[] sumGrad, double[] sumHess) {\n-    return !Maths.areZeros(sumGrad) && satisfyWeight(sumHess);\n-  }\n-\n-  /**\n-   * Calculate leaf weight given the statistics\n-   *\n-   * @param sumGrad sum of gradient values\n-   * @param sumHess sum of hessian values\n-   * @return weight\n-   */\n-  public double calcWeight(double sumGrad, double sumHess) {\n-    if (!satisfyWeight(sumHess) || sumGrad == 0.0) {\n-      return 0.0;\n-    }\n-    double dw;\n-    if (regAlpha == 0.0f) {\n-      dw = -sumGrad / (sumHess + regLambda);\n-    } else {\n-      dw = -Maths.thresholdL1(sumGrad, regAlpha) / (sumHess + regLambda);\n+\n+    public boolean satisfyWeight(double sumGrad, double sumHess) {\n+        return sumGrad != 0.0f && satisfyWeight(sumHess);\n     }\n-    if (maxLeafWeight != 0.0f) {\n-      if (dw > maxLeafWeight) {\n-        dw = maxLeafWeight;\n-      } else if (dw < -maxLeafWeight) {\n-        dw = -maxLeafWeight;\n-      }\n+\n+    /**\n+     * Whether the sum of hessian satisfies weight Since hessian matrix is positive, we have det(hess)\n+     * <= a11*a22*...*akk, thus we approximate det(hess) with a11*a22*...*akk\n+     *\n+     * @param sumHess sum of hessian values\n+     * @return true if satisfied, false otherwise\n+     */\n+    public boolean satisfyWeight(double[] sumHess) {\n+        if (minChildWeight == 0.0f) {\n+            return true;\n+        }\n+        double w = 1.0;\n+        if (!fullHessian) {\n+            for (double h : sumHess) {\n+                w *= h;\n+            }\n+        } else {\n+            for (int k = 0; k < numClass; k++) {\n+                int index = Maths.indexOfLowerTriangularMatrix(k, k);\n+                w *= sumHess[index];\n+            }\n+        }\n+        return w >= minChildWeight;\n     }\n-    return dw;\n-  }\n \n-  public double[] calcWeights(double[] sumGrad, double[] sumHess) {\n-    double[] weights = new double[numClass];\n-    if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n-      return weights;\n+    public boolean satisfyWeight(double[] sumGrad, double[] sumHess) {\n+        return !Maths.areZeros(sumGrad) && satisfyWeight(sumHess);\n     }\n-    // TODO: regularization\n-    if (!fullHessian) {\n-      if (regAlpha == 0.0f) {\n-        for (int k = 0; k < numClass; k++) {\n-          weights[k] = -sumGrad[k] / (sumHess[k] + regLambda);\n+\n+    /**\n+     * Calculate leaf weight given the statistics\n+     *\n+     * @param sumGrad sum of gradient values\n+     * @param sumHess sum of hessian values\n+     * @return weight\n+     */\n+    public double calcWeight(double sumGrad, double sumHess) {\n+        if (!satisfyWeight(sumHess) || sumGrad == 0.0) {\n+            return 0.0;\n         }\n-      } else {\n-        for (int k = 0; k < numClass; k++) {\n-          weights[k] = -Maths.thresholdL1(sumGrad[k], regAlpha) / (sumHess[k] + regLambda);\n+        double dw;\n+        if (regAlpha == 0.0f) {\n+            dw = -sumGrad / (sumHess + regLambda);\n+        } else {\n+            dw = -Maths.thresholdL1(sumGrad, regAlpha) / (sumHess + regLambda);\n         }\n-      }\n-    } else {\n-      addDiagonal(numClass, sumHess, regLambda);\n-      weights = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n-      for (int i = 0; i < numClass; i++) {\n-        weights[i] *= -1;\n-      }\n-      addDiagonal(numClass, sumHess, -regLambda);\n-    }\n-    if (maxLeafWeight != 0.0f) {\n-      for (int k = 0; k < numClass; k++) {\n-        if (weights[k] > maxLeafWeight) {\n-          weights[k] = maxLeafWeight;\n-        } else if (weights[k] < -maxLeafWeight) {\n-          weights[k] = -maxLeafWeight;\n+        if (maxLeafWeight != 0.0f) {\n+            if (dw > maxLeafWeight) {\n+                dw = maxLeafWeight;\n+            } else if (dw < -maxLeafWeight) {\n+                dw = -maxLeafWeight;\n+            }\n         }\n-      }\n+        return dw;\n     }\n-    return weights;\n-  }\n-\n-  /**\n-   * Calculate the cost of loss function\n-   *\n-   * @param sumGrad sum of gradient values\n-   * @param sumHess sum of hessian values\n-   * @return loss gain\n-   */\n-  public double calcGain(double sumGrad, double sumHess) {\n-    if (!satisfyWeight(sumHess) || sumGrad == 0.0f) {\n-      return 0.0f;\n-    }\n-    if (maxLeafWeight == 0.0f) {\n-      if (regAlpha == 0.0f) {\n-        return (sumGrad / (sumHess + regLambda)) * sumGrad;\n-      } else {\n-        return Maths.sqr(Maths.thresholdL1(sumGrad, regAlpha)) / (sumHess + regLambda);\n-      }\n-    } else {\n-      double w = calcWeight(sumGrad, sumHess);\n-      double ret = sumGrad * w + 0.5 * (sumHess + regLambda) * Maths.sqr(w);\n-      if (regAlpha == 0.0f) {\n-        return -2.0 * ret;\n-      } else {\n-        return -2.0 * (ret + regAlpha * Math.abs(w));\n-      }\n+\n+    public double[] calcWeights(double[] sumGrad, double[] sumHess) {\n+        double[] weights = new double[numClass];\n+        if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n+            return weights;\n+        }\n+        // TODO: regularization\n+        if (!fullHessian) {\n+            if (regAlpha == 0.0f) {\n+                for (int k = 0; k < numClass; k++) {\n+                    weights[k] = -sumGrad[k] / (sumHess[k] + regLambda);\n+                }\n+            } else {\n+                for (int k = 0; k < numClass; k++) {\n+                    weights[k] =\n+                            -Maths.thresholdL1(sumGrad[k], regAlpha) / (sumHess[k] + regLambda);\n+                }\n+            }\n+        } else {\n+            addDiagonal(numClass, sumHess, regLambda);\n+            weights = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n+            for (int i = 0; i < numClass; i++) {\n+                weights[i] *= -1;\n+            }\n+            addDiagonal(numClass, sumHess, -regLambda);\n+        }\n+        if (maxLeafWeight != 0.0f) {\n+            for (int k = 0; k < numClass; k++) {\n+                if (weights[k] > maxLeafWeight) {\n+                    weights[k] = maxLeafWeight;\n+                } else if (weights[k] < -maxLeafWeight) {\n+                    weights[k] = -maxLeafWeight;\n+                }\n+            }\n+        }\n+        return weights;\n     }\n-  }\n \n-  public double calcGain(double[] sumGrad, double[] sumHess) {\n-    double gain = 0.0;\n-    if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n-      return 0.0;\n+    /**\n+     * Calculate the cost of loss function\n+     *\n+     * @param sumGrad sum of gradient values\n+     * @param sumHess sum of hessian values\n+     * @return loss gain\n+     */\n+    public double calcGain(double sumGrad, double sumHess) {\n+        if (!satisfyWeight(sumHess) || sumGrad == 0.0f) {\n+            return 0.0f;\n+        }\n+        if (maxLeafWeight == 0.0f) {\n+            if (regAlpha == 0.0f) {\n+                return (sumGrad / (sumHess + regLambda)) * sumGrad;\n+            } else {\n+                return Maths.sqr(Maths.thresholdL1(sumGrad, regAlpha)) / (sumHess + regLambda);\n+            }\n+        } else {\n+            double w = calcWeight(sumGrad, sumHess);\n+            double ret = sumGrad * w + 0.5 * (sumHess + regLambda) * Maths.sqr(w);\n+            if (regAlpha == 0.0f) {\n+                return -2.0 * ret;\n+            } else {\n+                return -2.0 * (ret + regAlpha * Math.abs(w));\n+            }\n+        }\n     }\n-    // TODO: regularization\n-    if (!fullHessian) {\n-      if (regAlpha == 0.0f) {\n-        for (int k = 0; k < numClass; k++) {\n-          gain += sumGrad[k] / (sumHess[k] + regLambda) * sumGrad[k];\n+\n+    public double calcGain(double[] sumGrad, double[] sumHess) {\n+        double gain = 0.0;\n+        if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n+            return 0.0;\n+        }\n+        // TODO: regularization\n+        if (!fullHessian) {\n+            if (regAlpha == 0.0f) {\n+                for (int k = 0; k < numClass; k++) {\n+                    gain += sumGrad[k] / (sumHess[k] + regLambda) * sumGrad[k];\n+                }\n+            } else {\n+                for (int k = 0; k < numClass; k++) {\n+                    gain += Maths.sqr(Maths.thresholdL1(sumGrad[k], regAlpha)) *\n+                            (sumHess[k] + regLambda);\n+                }\n+            }\n+        } else {\n+            addDiagonal(numClass, sumHess, regLambda);\n+            double[] tmp =\n+                    Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n+            gain = Maths.dot(sumGrad, tmp);\n+            addDiagonal(numClass, sumHess, -regLambda);\n         }\n-      } else {\n-        for (int k = 0; k < numClass; k++) {\n-          gain += Maths.sqr(Maths.thresholdL1(sumGrad[k], regAlpha)) * (sumHess[k] + regLambda);\n+        return (float) (gain / numClass);\n+    }\n+\n+    private void addDiagonal(int n, double[] sumHess, double v) {\n+        for (int i = 0; i < n; i++) {\n+            int index = Maths.indexOfLowerTriangularMatrix(i, i);\n+            sumHess[index] += v;\n         }\n-      }\n-    } else {\n-      addDiagonal(numClass, sumHess, regLambda);\n-      double[] tmp = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n-      gain = Maths.dot(sumGrad, tmp);\n-      addDiagonal(numClass, sumHess, -regLambda);\n     }\n-    return (float) (gain / numClass);\n-  }\n \n-  private void addDiagonal(int n, double[] sumHess, double v) {\n-    for (int i = 0; i < n; i++) {\n-      int index = Maths.indexOfLowerTriangularMatrix(i, i);\n-      sumHess[index] += v;\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(super.toString());\n+        sb.append(String.format(\"|numClass = %d\\n\", numClass));\n+        sb.append(String.format(\"|numTree = %d\\n\", numTree));\n+        sb.append(String.format(\"|numThread = %d\\n\", numThread));\n+        sb.append(String.format(\"|fullHessian = %s\\n\", fullHessian));\n+        sb.append(String.format(\"|minChildWeight = %f\\n\", minChildWeight));\n+        sb.append(String.format(\"|minNodeInstance = %d\\n\", minNodeInstance));\n+        sb.append(String.format(\"|regAlpha = %s\\n\", regAlpha));\n+        sb.append(String.format(\"|regLambda = %s\\n\", regLambda));\n+        sb.append(String.format(\"|maxLeafWeight = %s\\n\", maxLeafWeight));\n+        sb.append(String.format(\"|lossFunc = %s\\n\", lossFunc));\n+        sb.append(String.format(\"|evalMetrics = %s\\n\", Arrays.toString(evalMetrics)));\n+        return sb.toString();\n     }\n-  }\n-\n-  @Override\n-  public String toString() {\n-    StringBuilder sb = new StringBuilder(super.toString());\n-    sb.append(String.format(\"|numClass = %d\\n\", numClass));\n-    sb.append(String.format(\"|numTree = %d\\n\", numTree));\n-    sb.append(String.format(\"|numThread = %d\\n\", numThread));\n-    sb.append(String.format(\"|fullHessian = %s\\n\", fullHessian));\n-    sb.append(String.format(\"|minChildWeight = %f\\n\", minChildWeight));\n-    sb.append(String.format(\"|minNodeInstance = %d\\n\", minNodeInstance));\n-    sb.append(String.format(\"|regAlpha = %s\\n\", regAlpha));\n-    sb.append(String.format(\"|regLambda = %s\\n\", regLambda));\n-    sb.append(String.format(\"|maxLeafWeight = %s\\n\", maxLeafWeight));\n-    sb.append(String.format(\"|lossFunc = %s\\n\", lossFunc));\n-    sb.append(String.format(\"|evalMetrics = %s\\n\", Arrays.toString(evalMetrics)));\n-    return sb.toString();\n-  }\n }\n \n",
            "diff_size": 273
        },
        {
            "tool": "naturalize",
            "violations": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/141/GBDTParam.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/141/GBDTParam.java\nindex 9dd14bd185c..31b7879b4b4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/141/GBDTParam.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/141/GBDTParam.java\n@@ -23,21 +23,30 @@ import com.tencent.angel.spark.ml.tree.util.Maths;\n public class GBDTParam extends RegTParam {\n \n   public int numClass; // number of classes/labels\n+\n   public int numTree;  // number of trees\n+\n   public int numThread;  // parallelism\n \n   public boolean histSubtraction;\n+\n   public boolean lighterChildFirst;\n   //public boolean leafwise;  // true if leaf-wise training, false if level-wise training\n \n   public boolean fullHessian;  // whether to use full hessian matrix instead of diagonal\n+\n   public float minChildWeight;  // minimum amount of hessian (weight) allowed for a child\n+\n   public int minNodeInstance;\n+\n   public float regAlpha;  // L1 regularization factor\n+\n   public float regLambda;  // L2 regularization factor\n+\n   public float maxLeafWeight; // maximum leaf weight, default 0 means no constraints\n \n   public String lossFunc; // name of loss function\n+\n   public String[] evalMetrics; // name of eval metric\n \n   /**\n@@ -46,6 +55,7 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return true if satisfied, false otherwise\n    */\n+\n   public boolean satisfyWeight(double sumHess) {\n     return sumHess >= minChildWeight;\n   }\n@@ -61,10 +71,12 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return true if satisfied, false otherwise\n    */\n+\n   public boolean satisfyWeight(double[] sumHess) {\n     if (minChildWeight == 0.0f) {\n       return true;\n     }\n+\n     double w = 1.0;\n     if (!fullHessian) {\n       for (double h : sumHess) {\n@@ -90,22 +102,25 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return weight\n    */\n+\n   public double calcWeight(double sumGrad, double sumHess) {\n     if (!satisfyWeight(sumHess) || sumGrad == 0.0) {\n       return 0.0;\n     }\n+\n     double dw;\n     if (regAlpha == 0.0f) {\n       dw = -sumGrad / (sumHess + regLambda);\n     } else {\n       dw = -Maths.thresholdL1(sumGrad, regAlpha) / (sumHess + regLambda);\n     }\n+\n     if (maxLeafWeight != 0.0f) {\n       if (dw > maxLeafWeight) {\n         dw = maxLeafWeight;\n       } else if (dw < -maxLeafWeight) {\n-        dw = -maxLeafWeight;\n-      }\n+               dw = -maxLeafWeight;\n+             }\n     }\n     return dw;\n   }\n@@ -116,6 +131,7 @@ public class GBDTParam extends RegTParam {\n       return weights;\n     }\n     // TODO: regularization\n+\n     if (!fullHessian) {\n       if (regAlpha == 0.0f) {\n         for (int k = 0; k < numClass; k++) {\n@@ -134,13 +150,14 @@ public class GBDTParam extends RegTParam {\n       }\n       addDiagonal(numClass, sumHess, -regLambda);\n     }\n+\n     if (maxLeafWeight != 0.0f) {\n       for (int k = 0; k < numClass; k++) {\n         if (weights[k] > maxLeafWeight) {\n           weights[k] = maxLeafWeight;\n         } else if (weights[k] < -maxLeafWeight) {\n-          weights[k] = -maxLeafWeight;\n-        }\n+                 weights[k] = -maxLeafWeight;\n+               }\n       }\n     }\n     return weights;\n@@ -153,10 +170,12 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return loss gain\n    */\n+\n   public double calcGain(double sumGrad, double sumHess) {\n     if (!satisfyWeight(sumHess) || sumGrad == 0.0f) {\n       return 0.0f;\n     }\n+\n     if (maxLeafWeight == 0.0f) {\n       if (regAlpha == 0.0f) {\n         return (sumGrad / (sumHess + regLambda)) * sumGrad;\n@@ -180,6 +199,7 @@ public class GBDTParam extends RegTParam {\n       return 0.0;\n     }\n     // TODO: regularization\n+\n     if (!fullHessian) {\n       if (regAlpha == 0.0f) {\n         for (int k = 0; k < numClass; k++) {\n@@ -222,5 +242,5 @@ public class GBDTParam extends RegTParam {\n     sb.append(String.format(\"|evalMetrics = %s\\n\", Arrays.toString(evalMetrics)));\n     return sb.toString();\n   }\n-}\n \n+}\n\\ No newline at end of file\n",
            "diff_size": 26
        },
        {
            "tool": "styler_random",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "checkstyle_idea",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}