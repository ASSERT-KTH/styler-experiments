{
    "project_name": "Angel-ML-angel",
    "violation_id": "120",
    "information": {
        "violations": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "checkstyle_idea",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/120/Histogram.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/120/Histogram.java\nindex 4aa817a588a..eb453ade66a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/120/Histogram.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/checkstyle_idea/120/Histogram.java\n@@ -24,322 +24,322 @@ import java.util.Arrays;\n \n public class Histogram implements Serializable {\n \n-  private int numBin;\n-  private int numClass;\n-  private boolean fullHessian;\n-  private double[] gradients;\n-  private double[] hessians;\n+    private int numBin;\n+    private int numClass;\n+    private boolean fullHessian;\n+    private double[] gradients;\n+    private double[] hessians;\n \n-  public Histogram(int numBin, int numClass, boolean fullHessian) {\n-    this.numBin = numBin;\n-    this.numClass = numClass;\n-    this.fullHessian = fullHessian;\n-    if (numClass == 2) {\n-      this.gradients = new double[numBin];\n-      this.hessians = new double[numBin];\n-    } else if (!fullHessian) {\n-      this.gradients = new double[numBin * numClass];\n-      this.hessians = new double[numBin * numClass];\n-    } else {\n-      this.gradients = new double[numBin * numClass];\n-      this.hessians = new double[numBin * ((numClass * (numClass + 1)) >> 1)];\n+    public Histogram(int numBin, int numClass, boolean fullHessian) {\n+        this.numBin = numBin;\n+        this.numClass = numClass;\n+        this.fullHessian = fullHessian;\n+        if (numClass == 2) {\n+            this.gradients = new double[numBin];\n+            this.hessians = new double[numBin];\n+        } else if (!fullHessian) {\n+            this.gradients = new double[numBin * numClass];\n+            this.hessians = new double[numBin * numClass];\n+        } else {\n+            this.gradients = new double[numBin * numClass];\n+            this.hessians = new double[numBin * ((numClass * (numClass + 1)) >> 1)];\n+        }\n     }\n-  }\n-\n-  public void accumulate(int index, double grad, double hess) {\n-    gradients[index] += grad;\n-    hessians[index] += hess;\n-  }\n \n-  public void accumulate(int index, double[] grad, double[] hess) {\n-    if (!fullHessian) {\n-      accumulate(index, grad, hess, 0);\n-    } else {\n-      accumulate(index, grad, 0, hess, 0);\n+    public void accumulate(int index, double grad, double hess) {\n+        gradients[index] += grad;\n+        hessians[index] += hess;\n     }\n-  }\n \n-  public void accumulate(int index, double[] grad, double[] hess, int offset) {\n-    int binOffset = index * numClass;\n-    for (int i = 0; i < numClass; i++) {\n-      gradients[binOffset + i] += grad[offset + i];\n-      hessians[binOffset + i] += hess[offset + i];\n+    public void accumulate(int index, double[] grad, double[] hess) {\n+        if (!fullHessian) {\n+            accumulate(index, grad, hess, 0);\n+        } else {\n+            accumulate(index, grad, 0, hess, 0);\n+        }\n     }\n-  }\n \n-  public void accumulate(int index, double[] grad, int gradOffset,\n-      double[] hess, int hessOffset) {\n-    int gradBinOffset = index * numClass;\n-    int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n-    for (int i = 0; i < grad.length; i++) {\n-      gradients[gradBinOffset + i] += grad[gradOffset + i];\n+    public void accumulate(int index, double[] grad, double[] hess, int offset) {\n+        int binOffset = index * numClass;\n+        for (int i = 0; i < numClass; i++) {\n+            gradients[binOffset + i] += grad[offset + i];\n+            hessians[binOffset + i] += hess[offset + i];\n+        }\n     }\n-    for (int i = 0; i < hess.length; i++) {\n-      hessians[hessBinOffset + i] += hess[hessOffset + i];\n+\n+    public void accumulate(int index, double[] grad, int gradOffset,\n+                           double[] hess, int hessOffset) {\n+        int gradBinOffset = index * numClass;\n+        int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n+        for (int i = 0; i < grad.length; i++) {\n+            gradients[gradBinOffset + i] += grad[gradOffset + i];\n+        }\n+        for (int i = 0; i < hess.length; i++) {\n+            hessians[hessBinOffset + i] += hess[hessOffset + i];\n+        }\n     }\n-  }\n \n-  public void accumulate(int index, GradPair gradPair) {\n-    if (numClass == 2) {\n-      BinaryGradPair binary = (BinaryGradPair) gradPair;\n-      gradients[index] += binary.getGrad();\n-      hessians[index] += binary.getHess();\n-    } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gradPair;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        gradients[offset + i] += grad[i];\n-        hessians[offset + i] += hess[i];\n-      }\n-    } else {\n-      MultiGradPair multi = (MultiGradPair) gradPair;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * numClass;\n-      int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n-      for (int i = 0; i < grad.length; i++) {\n-        gradients[gradOffset + i] += grad[i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hessians[hessOffset + i] += hess[i];\n-      }\n+    public void accumulate(int index, GradPair gradPair) {\n+        if (numClass == 2) {\n+            BinaryGradPair binary = (BinaryGradPair) gradPair;\n+            gradients[index] += binary.getGrad();\n+            hessians[index] += binary.getHess();\n+        } else if (!fullHessian) {\n+            MultiGradPair multi = (MultiGradPair) gradPair;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                gradients[offset + i] += grad[i];\n+                hessians[offset + i] += hess[i];\n+            }\n+        } else {\n+            MultiGradPair multi = (MultiGradPair) gradPair;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int gradOffset = index * numClass;\n+            int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n+            for (int i = 0; i < grad.length; i++) {\n+                gradients[gradOffset + i] += grad[i];\n+            }\n+            for (int i = 0; i < hess.length; i++) {\n+                hessians[hessOffset + i] += hess[i];\n+            }\n+        }\n     }\n-  }\n \n-  public Histogram plus(Histogram other) {\n-    Histogram res = new Histogram(numBin, numClass, fullHessian);\n-    if (numClass == 2 || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] + other.gradients[i];\n-        res.hessians[i] = this.hessians[i] + other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] + other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        res.hessians[i] = this.hessians[i] + other.hessians[i];\n-      }\n+    public Histogram plus(Histogram other) {\n+        Histogram res = new Histogram(numBin, numClass, fullHessian);\n+        if (numClass == 2 || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] + other.gradients[i];\n+                res.hessians[i] = this.hessians[i] + other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] + other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                res.hessians[i] = this.hessians[i] + other.hessians[i];\n+            }\n+        }\n+        return res;\n     }\n-    return res;\n-  }\n \n-  public Histogram subtract(Histogram other) {\n-    Histogram res = new Histogram(numBin, numClass, fullHessian);\n-    if (numClass == 2 || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] - other.gradients[i];\n-        res.hessians[i] = this.hessians[i] - other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] - other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        res.hessians[i] = this.hessians[i] - other.hessians[i];\n-      }\n+    public Histogram subtract(Histogram other) {\n+        Histogram res = new Histogram(numBin, numClass, fullHessian);\n+        if (numClass == 2 || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] - other.gradients[i];\n+                res.hessians[i] = this.hessians[i] - other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] - other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                res.hessians[i] = this.hessians[i] - other.hessians[i];\n+            }\n+        }\n+        return res;\n     }\n-    return res;\n-  }\n \n-  public void plusBy(Histogram other) {\n-    if (numClass == 2 || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] += other.gradients[i];\n-        this.hessians[i] += other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] += other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        this.hessians[i] += other.hessians[i];\n-      }\n+    public void plusBy(Histogram other) {\n+        if (numClass == 2 || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] += other.gradients[i];\n+                this.hessians[i] += other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] += other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                this.hessians[i] += other.hessians[i];\n+            }\n+        }\n     }\n-  }\n \n-  public void subtractBy(Histogram other) {\n-    if (numClass == 2 || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] -= other.gradients[i];\n-        this.hessians[i] -= other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] -= other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        this.hessians[i] -= other.hessians[i];\n-      }\n+    public void subtractBy(Histogram other) {\n+        if (numClass == 2 || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] -= other.gradients[i];\n+                this.hessians[i] -= other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] -= other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                this.hessians[i] -= other.hessians[i];\n+            }\n+        }\n     }\n-  }\n \n-  public GradPair sum() {\n-    return sum(0, numBin);\n-  }\n+    public GradPair sum() {\n+        return sum(0, numBin);\n+    }\n \n-  public GradPair sum(int start, int end) {\n-    if (numClass == 2) {\n-      double sumGrad = 0.0;\n-      double sumHess = 0.0;\n-      for (int i = start; i < end; i++) {\n-        sumGrad += gradients[i];\n-        sumHess += hessians[i];\n-      }\n-      return new BinaryGradPair(sumGrad, sumHess);\n-    } else if (!fullHessian) {\n-      double[] sumGrad = new double[numClass];\n-      double[] sumHess = new double[numClass];\n-      for (int i = start * numClass; i < end * numClass; i += numClass) {\n-        for (int j = 0; j < numClass; j++) {\n-          sumGrad[j] += gradients[i + j];\n-          sumHess[j] += hessians[i + j];\n-        }\n-      }\n-      return new MultiGradPair(sumGrad, sumHess);\n-    } else {\n-      double[] sumGrad = new double[numClass];\n-      double[] sumHess = new double[(numClass * (numClass + 1)) >> 1];\n-      for (int i = start; i < end; i++) {\n-        int gradOffset = i * sumGrad.length;\n-        for (int j = 0; j < sumGrad.length; j++) {\n-          sumGrad[j] += gradients[gradOffset + j];\n+    public GradPair sum(int start, int end) {\n+        if (numClass == 2) {\n+            double sumGrad = 0.0;\n+            double sumHess = 0.0;\n+            for (int i = start; i < end; i++) {\n+                sumGrad += gradients[i];\n+                sumHess += hessians[i];\n+            }\n+            return new BinaryGradPair(sumGrad, sumHess);\n+        } else if (!fullHessian) {\n+            double[] sumGrad = new double[numClass];\n+            double[] sumHess = new double[numClass];\n+            for (int i = start * numClass; i < end * numClass; i += numClass) {\n+                for (int j = 0; j < numClass; j++) {\n+                    sumGrad[j] += gradients[i + j];\n+                    sumHess[j] += hessians[i + j];\n+                }\n+            }\n+            return new MultiGradPair(sumGrad, sumHess);\n+        } else {\n+            double[] sumGrad = new double[numClass];\n+            double[] sumHess = new double[(numClass * (numClass + 1)) >> 1];\n+            for (int i = start; i < end; i++) {\n+                int gradOffset = i * sumGrad.length;\n+                for (int j = 0; j < sumGrad.length; j++) {\n+                    sumGrad[j] += gradients[gradOffset + j];\n+                }\n+                int hessOffset = i * sumHess.length;\n+                for (int j = 0; j < sumHess.length; j++) {\n+                    sumHess[j] += hessians[hessOffset + j];\n+                }\n+            }\n+            return new MultiGradPair(sumGrad, sumHess);\n         }\n-        int hessOffset = i * sumHess.length;\n-        for (int j = 0; j < sumHess.length; j++) {\n-          sumHess[j] += hessians[hessOffset + j];\n-        }\n-      }\n-      return new MultiGradPair(sumGrad, sumHess);\n     }\n-  }\n \n-  public int getNumBin() {\n-    return numBin;\n-  }\n+    public int getNumBin() {\n+        return numBin;\n+    }\n \n-  public GradPair get(int index) {\n-    if (numClass == 2) {\n-      return new BinaryGradPair(gradients[index], hessians[index]);\n-    } else {\n-      double[] grad = Arrays.copyOfRange(gradients,\n-          index * numClass, (index + 1) * numClass);\n-      int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n-      double[] hess = Arrays.copyOfRange(hessians,\n-          index * size, (index + 1) * size);\n-      return new MultiGradPair(grad, hess);\n+    public GradPair get(int index) {\n+        if (numClass == 2) {\n+            return new BinaryGradPair(gradients[index], hessians[index]);\n+        } else {\n+            double[] grad = Arrays.copyOfRange(gradients,\n+                    index * numClass, (index + 1) * numClass);\n+            int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n+            double[] hess = Arrays.copyOfRange(hessians,\n+                    index * size, (index + 1) * size);\n+            return new MultiGradPair(grad, hess);\n+        }\n     }\n-  }\n \n-  public void put(int index, GradPair gp) {\n-    if (numClass == 2) {\n-      ((BinaryGradPair) gp).set(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      ((MultiGradPair) gp).set(gradients, hessians, index * numClass);\n-    } else {\n-      int gradOffset = index * numClass;\n-      int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n-      ((MultiGradPair) gp).set(gradients, gradOffset, hessians, hessOffset);\n+    public void put(int index, GradPair gp) {\n+        if (numClass == 2) {\n+            ((BinaryGradPair) gp).set(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            ((MultiGradPair) gp).set(gradients, hessians, index * numClass);\n+        } else {\n+            int gradOffset = index * numClass;\n+            int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n+            ((MultiGradPair) gp).set(gradients, gradOffset, hessians, hessOffset);\n+        }\n     }\n-  }\n \n-  public void plusTo(GradPair gp, int index) {\n-    if (numClass == 2) {\n-      ((BinaryGradPair) gp).plusBy(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] += gradients[offset + i];\n-        hess[i] += hessians[offset + i];\n-      }\n-    } else {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * grad.length;\n-      int hessOffset = index * hess.length;\n-      for (int i = 0; i < grad.length; i++) {\n-        grad[i] += gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hess[i] += hessians[hessOffset + i];\n-      }\n+    public void plusTo(GradPair gp, int index) {\n+        if (numClass == 2) {\n+            ((BinaryGradPair) gp).plusBy(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                grad[i] += gradients[offset + i];\n+                hess[i] += hessians[offset + i];\n+            }\n+        } else {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int gradOffset = index * grad.length;\n+            int hessOffset = index * hess.length;\n+            for (int i = 0; i < grad.length; i++) {\n+                grad[i] += gradients[gradOffset + i];\n+            }\n+            for (int i = 0; i < hess.length; i++) {\n+                hess[i] += hessians[hessOffset + i];\n+            }\n+        }\n     }\n-  }\n \n-  public void subtractTo(GradPair gp, int index) {\n-    if (numClass == 2) {\n-      ((BinaryGradPair) gp).subtractBy(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] -= gradients[offset + i];\n-        hess[i] -= hessians[offset + i];\n-      }\n-    } else {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * grad.length;\n-      int hessOffset = index * hess.length;\n-      for (int i = 0; i < grad.length; i++) {\n-        grad[i] -= gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hess[i] -= hessians[hessOffset + i];\n-      }\n+    public void subtractTo(GradPair gp, int index) {\n+        if (numClass == 2) {\n+            ((BinaryGradPair) gp).subtractBy(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                grad[i] -= gradients[offset + i];\n+                hess[i] -= hessians[offset + i];\n+            }\n+        } else {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int gradOffset = index * grad.length;\n+            int hessOffset = index * hess.length;\n+            for (int i = 0; i < grad.length; i++) {\n+                grad[i] -= gradients[gradOffset + i];\n+            }\n+            for (int i = 0; i < hess.length; i++) {\n+                hess[i] -= hessians[hessOffset + i];\n+            }\n+        }\n     }\n-  }\n \n-  public void scan(int index, GradPair left, GradPair right) {\n-    if (numClass == 2) {\n-      ((BinaryGradPair) left).plusBy(gradients[index], hessians[index]);\n-      ((BinaryGradPair) right).subtractBy(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      MultiGradPair leftMulti = (MultiGradPair) left;\n-      double[] leftGrad = leftMulti.getGrad();\n-      double[] leftHess = leftMulti.getHess();\n-      MultiGradPair rightMulti = (MultiGradPair) right;\n-      double[] rightGrad = rightMulti.getGrad();\n-      double[] rightHess = rightMulti.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        leftGrad[i] += gradients[offset + i];\n-        leftHess[i] += hessians[offset + i];\n-        rightGrad[i] -= gradients[offset + i];\n-        rightHess[i] -= hessians[offset + i];\n-      }\n-    } else {\n-      MultiGradPair leftMulti = (MultiGradPair) left;\n-      double[] leftGrad = leftMulti.getGrad();\n-      double[] leftHess = leftMulti.getHess();\n-      MultiGradPair rightMulti = (MultiGradPair) right;\n-      double[] rightGrad = rightMulti.getGrad();\n-      double[] rightHess = rightMulti.getHess();\n-      int gradOffset = index * leftGrad.length;\n-      int hessOffset = index * leftHess.length;\n-      for (int i = 0; i < leftGrad.length; i++) {\n-        leftGrad[i] += gradients[gradOffset + i];\n-        rightGrad[i] -= gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < leftHess.length; i++) {\n-        leftHess[i] += hessians[hessOffset + i];\n-        rightHess[i] -= hessians[hessOffset + i];\n-      }\n+    public void scan(int index, GradPair left, GradPair right) {\n+        if (numClass == 2) {\n+            ((BinaryGradPair) left).plusBy(gradients[index], hessians[index]);\n+            ((BinaryGradPair) right).subtractBy(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            MultiGradPair leftMulti = (MultiGradPair) left;\n+            double[] leftGrad = leftMulti.getGrad();\n+            double[] leftHess = leftMulti.getHess();\n+            MultiGradPair rightMulti = (MultiGradPair) right;\n+            double[] rightGrad = rightMulti.getGrad();\n+            double[] rightHess = rightMulti.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                leftGrad[i] += gradients[offset + i];\n+                leftHess[i] += hessians[offset + i];\n+                rightGrad[i] -= gradients[offset + i];\n+                rightHess[i] -= hessians[offset + i];\n+            }\n+        } else {\n+            MultiGradPair leftMulti = (MultiGradPair) left;\n+            double[] leftGrad = leftMulti.getGrad();\n+            double[] leftHess = leftMulti.getHess();\n+            MultiGradPair rightMulti = (MultiGradPair) right;\n+            double[] rightGrad = rightMulti.getGrad();\n+            double[] rightHess = rightMulti.getHess();\n+            int gradOffset = index * leftGrad.length;\n+            int hessOffset = index * leftHess.length;\n+            for (int i = 0; i < leftGrad.length; i++) {\n+                leftGrad[i] += gradients[gradOffset + i];\n+                rightGrad[i] -= gradients[gradOffset + i];\n+            }\n+            for (int i = 0; i < leftHess.length; i++) {\n+                leftHess[i] += hessians[hessOffset + i];\n+                rightHess[i] -= hessians[hessOffset + i];\n+            }\n+        }\n     }\n-  }\n \n-  public void clear() {\n-    Arrays.fill(gradients, 0.0);\n-    Arrays.fill(hessians, 0.0);\n-  }\n+    public void clear() {\n+        Arrays.fill(gradients, 0.0);\n+        Arrays.fill(hessians, 0.0);\n+    }\n \n }\n",
            "diff_size": 312
        },
        {
            "tool": "naturalize",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/120/Histogram.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/120/Histogram.java\nindex 4aa817a588a..3dff9d9e029 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/120/Histogram.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/naturalize/120/Histogram.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.spark.ml.tree.gbdt.histogram;\n \n import java.io.Serializable;\n@@ -67,9 +66,8 @@ public class Histogram implements Serializable {\n     }\n   }\n \n-  public void accumulate(int index, double[] grad, int gradOffset,\n-      double[] hess, int hessOffset) {\n-    int gradBinOffset = index * numClass;\n+  public void accumulate(int index, double[] grad, int gradOffset, double[] hess, int hessOffset) {\n+  int gradBinOffset = index * numClass;\n     int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n     for (int i = 0; i < grad.length; i++) {\n       gradients[gradBinOffset + i] += grad[gradOffset + i];\n@@ -224,11 +222,9 @@ public class Histogram implements Serializable {\n     if (numClass == 2) {\n       return new BinaryGradPair(gradients[index], hessians[index]);\n     } else {\n-      double[] grad = Arrays.copyOfRange(gradients,\n-          index * numClass, (index + 1) * numClass);\n+      double[] grad = Arrays.copyOfRange(gradients, index * numClass, (index + 1) * numClass);\n       int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n-      double[] hess = Arrays.copyOfRange(hessians,\n-          index * size, (index + 1) * size);\n+      double[] hess = Arrays.copyOfRange(hessians, index * size, (index + 1) * size);\n       return new MultiGradPair(grad, hess);\n     }\n   }\n@@ -342,4 +338,4 @@ public class Histogram implements Serializable {\n     Arrays.fill(hessians, 0.0);\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/120/Histogram.java b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/120/Histogram.java\nindex 4aa817a588a..244f27821a7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/violations/120/Histogram.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/src/experiments/projects/Angel-ML-angel/codebuff/120/Histogram.java\n@@ -21,7 +21,6 @@ package com.tencent.angel.spark.ml.tree.gbdt.histogram;\n import java.io.Serializable;\n import java.util.Arrays;\n \n-\n public class Histogram implements Serializable {\n \n   private int numBin;\n@@ -67,13 +66,13 @@ public class Histogram implements Serializable {\n     }\n   }\n \n-  public void accumulate(int index, double[] grad, int gradOffset,\n-      double[] hess, int hessOffset) {\n+  public void accumulate(int index, double[] grad, int gradOffset, double[] hess, int hessOffset) {\n     int gradBinOffset = index * numClass;\n     int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n     for (int i = 0; i < grad.length; i++) {\n       gradients[gradBinOffset + i] += grad[gradOffset + i];\n     }\n+\n     for (int i = 0; i < hess.length; i++) {\n       hessians[hessBinOffset + i] += hess[hessOffset + i];\n     }\n@@ -85,26 +84,27 @@ public class Histogram implements Serializable {\n       gradients[index] += binary.getGrad();\n       hessians[index] += binary.getHess();\n     } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gradPair;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        gradients[offset + i] += grad[i];\n-        hessians[offset + i] += hess[i];\n-      }\n+             MultiGradPair multi = (MultiGradPair) gradPair;\n+             double[] grad = multi.getGrad();\n+             double[] hess = multi.getHess();\n+             int offset = index * numClass;\n+             for (int i = 0; i < numClass; i++) {\n+               gradients[offset + i] += grad[i];\n+               hessians[offset + i] += hess[i];\n+             }\n     } else {\n-      MultiGradPair multi = (MultiGradPair) gradPair;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * numClass;\n-      int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n-      for (int i = 0; i < grad.length; i++) {\n-        gradients[gradOffset + i] += grad[i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hessians[hessOffset + i] += hess[i];\n-      }\n+             MultiGradPair multi = (MultiGradPair) gradPair;\n+             double[] grad = multi.getGrad();\n+             double[] hess = multi.getHess();\n+             int gradOffset = index * numClass;\n+             int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n+             for (int i = 0; i < grad.length; i++) {\n+               gradients[gradOffset + i] += grad[i];\n+             }\n+\n+             for (int i = 0; i < hess.length; i++) {\n+               hessians[hessOffset + i] += hess[i];\n+             }\n     }\n   }\n \n@@ -119,6 +119,7 @@ public class Histogram implements Serializable {\n       for (int i = 0; i < this.gradients.length; i++) {\n         res.gradients[i] = this.gradients[i] + other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n         res.hessians[i] = this.hessians[i] + other.hessians[i];\n       }\n@@ -137,6 +138,7 @@ public class Histogram implements Serializable {\n       for (int i = 0; i < this.gradients.length; i++) {\n         res.gradients[i] = this.gradients[i] - other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n         res.hessians[i] = this.hessians[i] - other.hessians[i];\n       }\n@@ -154,6 +156,7 @@ public class Histogram implements Serializable {\n       for (int i = 0; i < this.gradients.length; i++) {\n         this.gradients[i] += other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n         this.hessians[i] += other.hessians[i];\n       }\n@@ -170,6 +173,7 @@ public class Histogram implements Serializable {\n       for (int i = 0; i < this.gradients.length; i++) {\n         this.gradients[i] -= other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n         this.hessians[i] -= other.hessians[i];\n       }\n@@ -207,6 +211,7 @@ public class Histogram implements Serializable {\n         for (int j = 0; j < sumGrad.length; j++) {\n           sumGrad[j] += gradients[gradOffset + j];\n         }\n+\n         int hessOffset = i * sumHess.length;\n         for (int j = 0; j < sumHess.length; j++) {\n           sumHess[j] += hessians[hessOffset + j];\n@@ -224,11 +229,9 @@ public class Histogram implements Serializable {\n     if (numClass == 2) {\n       return new BinaryGradPair(gradients[index], hessians[index]);\n     } else {\n-      double[] grad = Arrays.copyOfRange(gradients,\n-          index * numClass, (index + 1) * numClass);\n+      double[] grad = Arrays.copyOfRange(gradients, index * numClass, (index + 1) * numClass);\n       int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n-      double[] hess = Arrays.copyOfRange(hessians,\n-          index * size, (index + 1) * size);\n+      double[] hess = Arrays.copyOfRange(hessians, index * size, (index + 1) * size);\n       return new MultiGradPair(grad, hess);\n     }\n   }\n@@ -249,26 +252,27 @@ public class Histogram implements Serializable {\n     if (numClass == 2) {\n       ((BinaryGradPair) gp).plusBy(gradients[index], hessians[index]);\n     } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] += gradients[offset + i];\n-        hess[i] += hessians[offset + i];\n-      }\n+             MultiGradPair multi = (MultiGradPair) gp;\n+             double[] grad = multi.getGrad();\n+             double[] hess = multi.getHess();\n+             int offset = index * numClass;\n+             for (int i = 0; i < numClass; i++) {\n+               grad[i] += gradients[offset + i];\n+               hess[i] += hessians[offset + i];\n+             }\n     } else {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * grad.length;\n-      int hessOffset = index * hess.length;\n-      for (int i = 0; i < grad.length; i++) {\n-        grad[i] += gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hess[i] += hessians[hessOffset + i];\n-      }\n+             MultiGradPair multi = (MultiGradPair) gp;\n+             double[] grad = multi.getGrad();\n+             double[] hess = multi.getHess();\n+             int gradOffset = index * grad.length;\n+             int hessOffset = index * hess.length;\n+             for (int i = 0; i < grad.length; i++) {\n+               grad[i] += gradients[gradOffset + i];\n+             }\n+\n+             for (int i = 0; i < hess.length; i++) {\n+               hess[i] += hessians[hessOffset + i];\n+             }\n     }\n   }\n \n@@ -276,26 +280,27 @@ public class Histogram implements Serializable {\n     if (numClass == 2) {\n       ((BinaryGradPair) gp).subtractBy(gradients[index], hessians[index]);\n     } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] -= gradients[offset + i];\n-        hess[i] -= hessians[offset + i];\n-      }\n+             MultiGradPair multi = (MultiGradPair) gp;\n+             double[] grad = multi.getGrad();\n+             double[] hess = multi.getHess();\n+             int offset = index * numClass;\n+             for (int i = 0; i < numClass; i++) {\n+               grad[i] -= gradients[offset + i];\n+               hess[i] -= hessians[offset + i];\n+             }\n     } else {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * grad.length;\n-      int hessOffset = index * hess.length;\n-      for (int i = 0; i < grad.length; i++) {\n-        grad[i] -= gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hess[i] -= hessians[hessOffset + i];\n-      }\n+             MultiGradPair multi = (MultiGradPair) gp;\n+             double[] grad = multi.getGrad();\n+             double[] hess = multi.getHess();\n+             int gradOffset = index * grad.length;\n+             int hessOffset = index * hess.length;\n+             for (int i = 0; i < grad.length; i++) {\n+               grad[i] -= gradients[gradOffset + i];\n+             }\n+\n+             for (int i = 0; i < hess.length; i++) {\n+               hess[i] -= hessians[hessOffset + i];\n+             }\n     }\n   }\n \n@@ -304,36 +309,37 @@ public class Histogram implements Serializable {\n       ((BinaryGradPair) left).plusBy(gradients[index], hessians[index]);\n       ((BinaryGradPair) right).subtractBy(gradients[index], hessians[index]);\n     } else if (!fullHessian) {\n-      MultiGradPair leftMulti = (MultiGradPair) left;\n-      double[] leftGrad = leftMulti.getGrad();\n-      double[] leftHess = leftMulti.getHess();\n-      MultiGradPair rightMulti = (MultiGradPair) right;\n-      double[] rightGrad = rightMulti.getGrad();\n-      double[] rightHess = rightMulti.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        leftGrad[i] += gradients[offset + i];\n-        leftHess[i] += hessians[offset + i];\n-        rightGrad[i] -= gradients[offset + i];\n-        rightHess[i] -= hessians[offset + i];\n-      }\n+             MultiGradPair leftMulti = (MultiGradPair) left;\n+             double[] leftGrad = leftMulti.getGrad();\n+             double[] leftHess = leftMulti.getHess();\n+             MultiGradPair rightMulti = (MultiGradPair) right;\n+             double[] rightGrad = rightMulti.getGrad();\n+             double[] rightHess = rightMulti.getHess();\n+             int offset = index * numClass;\n+             for (int i = 0; i < numClass; i++) {\n+               leftGrad[i] += gradients[offset + i];\n+               leftHess[i] += hessians[offset + i];\n+               rightGrad[i] -= gradients[offset + i];\n+               rightHess[i] -= hessians[offset + i];\n+             }\n     } else {\n-      MultiGradPair leftMulti = (MultiGradPair) left;\n-      double[] leftGrad = leftMulti.getGrad();\n-      double[] leftHess = leftMulti.getHess();\n-      MultiGradPair rightMulti = (MultiGradPair) right;\n-      double[] rightGrad = rightMulti.getGrad();\n-      double[] rightHess = rightMulti.getHess();\n-      int gradOffset = index * leftGrad.length;\n-      int hessOffset = index * leftHess.length;\n-      for (int i = 0; i < leftGrad.length; i++) {\n-        leftGrad[i] += gradients[gradOffset + i];\n-        rightGrad[i] -= gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < leftHess.length; i++) {\n-        leftHess[i] += hessians[hessOffset + i];\n-        rightHess[i] -= hessians[hessOffset + i];\n-      }\n+             MultiGradPair leftMulti = (MultiGradPair) left;\n+             double[] leftGrad = leftMulti.getGrad();\n+             double[] leftHess = leftMulti.getHess();\n+             MultiGradPair rightMulti = (MultiGradPair) right;\n+             double[] rightGrad = rightMulti.getGrad();\n+             double[] rightHess = rightMulti.getHess();\n+             int gradOffset = index * leftGrad.length;\n+             int hessOffset = index * leftHess.length;\n+             for (int i = 0; i < leftGrad.length; i++) {\n+               leftGrad[i] += gradients[gradOffset + i];\n+               rightGrad[i] -= gradients[gradOffset + i];\n+             }\n+\n+             for (int i = 0; i < leftHess.length; i++) {\n+               leftHess[i] += hessians[hessOffset + i];\n+               rightHess[i] -= hessians[hessOffset + i];\n+             }\n     }\n   }\n \n@@ -342,4 +348,4 @@ public class Histogram implements Serializable {\n     Arrays.fill(hessians, 0.0);\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 104
        },
        {
            "tool": "styler_random",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "violations": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "checkstyle_idea",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}